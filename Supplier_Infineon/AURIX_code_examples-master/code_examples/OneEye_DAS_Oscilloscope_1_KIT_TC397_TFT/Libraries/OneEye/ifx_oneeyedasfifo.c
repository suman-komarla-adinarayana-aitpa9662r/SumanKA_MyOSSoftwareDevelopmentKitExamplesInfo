/**
 * \file Ifx_OneEyeDasFifo.h
 * \brief Source file for our basebar on each display
 *
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 *
 */

#include "ifx_oneeyedasfifo.h"
#include "Bsp.h"
#include "IfxCpu_Intrinsics.h"
#include "stdlib.h"
static inline boolean Ifx_OneEyeDasFifo_CompareAndSet (volatile void * dst, uint32 old, uint32 new)
{
    return Ifx__cmpAndSwap((unsigned int *) dst, new, old) == old ? TRUE : FALSE;
}

static inline uint32 Ifx_OneEyeDasFifo_Dist (uint32 high, uint32 low, uint32 size)
{
    uint32 res;

    if (high >= low)
    {
        res = high - low; /* res = size - high + low i.e. res = size + (-res) */
    }
    else
    {
        res = size - low + high; /* res = size - high + low i.e. res = size + (-res) */
    }

    return res;
}

Ifx_SizeT Ifx_OneEyeDasFifo_write (Ifx_OneEyeDasFifo * fifo, char * src, Ifx_SizeT count,
        Ifx_TickTime timeout)
{
    const uint32 size = fifo->size;
    Ifx_OneEyeDasFifo_ToOneEye * const fifoTx = &fifo->tx;
    Ifx_OneEyeDasFifo_ToOneEyeControl controlNew;
    Ifx_OneEyeDasFifo_ToOneEyeControl controlOld;
    uint32 freeElements;
    /* reserve buffer */
    do
    {
        do
        {
            controlOld = fifoTx->control;
            controlNew = controlOld;
            controlNew.data.active = controlNew.data.active + count;
            /* Note that readPos is not part of the Ifx_OneEyeDasFifo_ToOneEyeControl structure. It is outside because it is accessed for write access only by OneEye
             * If OneEye writes concurrently (advances the readPos to be equal to writePos) the worst case is that we will believe that there is not enough memory, and iterate once in the loop for nothing.
             */
            uint32 pending = Ifx_OneEyeDasFifo_Dist(controlOld.data.writepos, fifoTx->readPos, size);
            freeElements = (size - 1) - pending - controlOld.data.active; // -1 because we can't have the counter have same values after writing (would be same state as buffer empty)
            if (freeElements > count)
            {
                break;
            }
        }while (isDeadLine(timeout) == FALSE);

        if (freeElements <= count)
        {
            // timeout -> do not write
            return count;
        }

    }while (Ifx_OneEyeDasFifo_CompareAndSet(&(fifoTx->control.value), controlOld.value, controlNew.value) == FALSE);

    /* write data */
    uint32 start = (controlOld.data.writepos + controlOld.data.active) % (size);
    uint32 stop = start + count;
    for (uint32 i = start; i < stop; i++)
    {
        fifoTx->data[i % (size)] = src[i - start];
    }

    /* increment ready and notify that data is readable if possible */
    do
    {
        controlOld = fifoTx->control;
        controlNew = controlOld;
        controlNew.data.ready = controlNew.data.ready + count;
        if (controlNew.data.ready == controlNew.data.active)
        {
            /* we're the last writer, mark data as readable */
            controlNew.data.writepos = (controlNew.data.writepos + controlNew.data.active) % (size);
            controlNew.data.active = 0;
            controlNew.data.ready = 0;
        }
    }while (Ifx_OneEyeDasFifo_CompareAndSet(&fifoTx->control.value, controlOld.value, controlNew.value) == FALSE);
    return 0;
}

Ifx_SizeT Ifx_OneEyeDasFifo_read (Ifx_OneEyeDasFifo * fifo, char * dst, Ifx_SizeT * count, Ifx_TickTime timeout)
{
    const uint32 size = fifo->size;
    Ifx_OneEyeDasFifo_FromOneEye * const fifoRx = &fifo->rx;
    /* OneEye will no access rxPending as long as it's not empty, so protected access is not required. It is assumed FifoRead is called in only one context on the target */
    // Find number of readable bytes (limited either by count or actually pending bytes)
    uint16 pending = Ifx_OneEyeDasFifo_Dist(fifoRx->control.rxEnd, fifoRx->control.rxBeg, size);
    uint16 readable = __minX(*count, pending);

    if (readable > 0)
    {
        // Copy data
        for (uint32 i = fifoRx->control.rxBeg; i < fifoRx->control.rxBeg + readable; i++)
        {
            dst[i - fifoRx->control.rxBeg] = fifoRx->data[i % size];
        }

        fifoRx->control.rxBeg = (fifoRx->control.rxBeg + readable) % size;
    }
    *count = readable;
    return pending - readable;
}

void Ifx_OneEyeDasFifo_clearRx (Ifx_OneEyeDasFifo * fifo)
{
    fifo->rx.control.rxBeg = 0;
    fifo->rx.control.rxEnd = 0;
}

void Ifx_OneEyeDasFifo_clearTx (Ifx_OneEyeDasFifo * fifo)
{
    Ifx_OneEyeDasFifo_ToOneEyeControl controlNew;
    Ifx_OneEyeDasFifo_ToOneEyeControl controlOld;
    do
    {
        controlOld = fifo->tx.control;
        controlNew.value = 0;
    }while (Ifx_OneEyeDasFifo_CompareAndSet(&fifo->tx.control.value, controlOld.value, controlNew.value) == FALSE);
}


void Ifx_OneEyeDasFifo_initConfig(Ifx_OneEyeDasFifo_Config * config)
{
	config->size = 512;
}


boolean Ifx_OneEyeDasFifo_init (Ifx_OneEyeDasFifo * fifo, Ifx_OneEyeDasFifo_Config * config)
{

    if(config->size > 1024){
        return FALSE;
    }

    fifo->rx.data = (char *)malloc(config->size);
    fifo->tx.data = (char *)malloc(config->size);

    if ((fifo->rx.data == NULL_PTR) || (fifo->tx.data == NULL_PTR))
    {
        fifo->size = 0;
        free(fifo->rx.data);
        free(fifo->tx.data);
        return FALSE;
    }

    fifo->size = config->size;
    return TRUE;
}
