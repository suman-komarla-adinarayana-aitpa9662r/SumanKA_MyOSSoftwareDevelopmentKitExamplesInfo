/**
 * \file ifx_oe_syncprotocol.c
 *
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
#include "ifx_oe_syncprotocol.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#if IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_QT
/* QT */
#include <QDebug>
#include <QDateTime>

/** Print debug information */
//#define IFX_OE_SYNCPROTOCOL_DEBUG(INFO) qInfo() << INFO
#define IFX_OE_SYNCPROTOCOL_DEBUG(INFO)
#define IFX_OE_SYNCPROTOCOL_WARNING(INFO) qWarning() << INFO
//#define IFX_OE_SYNCPROTOCOL_WARNING(INFO)
#define ASSERT(X) Q_ASSERT_X(X, "", "")
#define IFX_OE_SYNCPROTOCOL_CURRENT_TIME QDateTime::currentMSecsSinceEpoch()
#define IFX_OE_SYNCPROTOCOL_UNUSED(x) Q_UNUSED(x)

#elif IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_AURIX

#define IFX_OE_SYNCPROTOCOL_DEBUG(INFO)
#define IFX_OE_SYNCPROTOCOL_WARNING(INFO)
#define ASSERT(X) IFX_OE_ASSERT(X)

#define IFX_OE_SYNCPROTOCOL_CURRENT_TIME Ifx_Oe_Time_now()
#define IFX_OE_SYNCPROTOCOL_UNUSED(x) IFX_OE_UNUSED(x)

#endif

#if IFX_OE_SYNCPROTOCOL_USE_PRIVATE_HEAP != 0
inline void* Ifx_Oe_SyncProtocol_malloc(Ifx_Oe_Malloc_Pool* memoryPool, size_t size)
{ return Ifx_Oe_Malloc_malloc(memoryPool, size); }

inline void Ifx_Oe_SyncProtocol_free(void* ptr)
{ Ifx_Oe_Malloc_free(ptr); }

inline void* Ifx_Oe_SyncProtocol_realloc(void* ptr, size_t size)
{ return Ifx_Oe_Malloc_realloc(ptr, size); }

#else

inline void* Ifx_Oe_SyncProtocol_malloc(Ifx_Oe_Malloc_Pool* memoryPool, size_t size)
{ IFX_OE_SYNCPROTOCOL_UNUSED(memoryPool);  return malloc(size); }

inline void Ifx_Oe_SyncProtocol_free(void* ptr)
{ free(ptr); }

inline void* Ifx_Oe_SyncProtocol_realloc(void* ptr, size_t size)
{ return realloc(ptr, size); }

#endif

/**
 * @brief Calculate the checksum of the header
 * @param header Header
 * @return checksum
 */
static uint8 Ifx_Oe_SyncProtocol_calculateFrameHeaderChecksum(Ifx_Oe_SyncProtocol_FrameHeader* header);
/**
 * @brief Calculate the checksum of the payload
 * @param header Frame header
 * @param messageHeader Message header
 * @param messagePayload Message payload
 * @return checksum
 */
static uint8 Ifx_Oe_SyncProtocol_calculateFramePayloadChecksum(Ifx_Oe_SyncProtocol_FrameHeader* header, Ifx_Oe_SyncProtocol_MessageHeader* messageHeader, uint8* messagePayload);
static uint8 Ifx_Oe_SyncProtocol_getNextIndex(uint8 currentIndex);
static uint8 Ifx_Oe_SyncProtocol_getNewIndex(Ifx_Oe_SyncProtocol* protocol);

/**
 * @brief Fill in the ACK information and return TRUE if ACK need to be send
 */
static boolean Ifx_Oe_SyncProtocol_setAck(Ifx_Oe_SyncProtocol* protocol, Ifx_Oe_SyncProtocol_FrameHeader* header);

/**
 * @brief Send the frame
 *
 * The whole frame might be send over multiple call
 *
 */
static boolean Ifx_Oe_SyncProtocol_sendPayload(Ifx_Oe_SyncProtocol* protocol);
static boolean Ifx_Oe_SyncProtocol_checkPendingAck(Ifx_Oe_SyncProtocol* protocol);
static void    Ifx_Oe_SyncProtocol_processOutgoing(Ifx_Oe_SyncProtocol* protocol);
static void    Ifx_Oe_SyncProtocol_raiseAck(Ifx_Oe_SyncProtocol* protocol, uint8 frameIndex, uint8 ackStatus);
static void    Ifx_Oe_SyncProtocol_processAck(Ifx_Oe_SyncProtocol* protocol, Ifx_Oe_SyncProtocol_FrameHeader* header);
static void    Ifx_Oe_SyncProtocol_readHeader(Ifx_Oe_SyncProtocol* protocol);
static void    Ifx_Oe_SyncProtocol_processIncomming(Ifx_Oe_SyncProtocol* protocol);

#if IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_QT

static inline sint32 Ifx_Oe_SyncProtocol_DPipeWrite(Ifx_Oe_SyncProtocol_DPipeStdIf* dPipeStdif, const void* data, sint32 count)
{
    Ifx_Oe_SyncProtocol_FifoSize c = (Ifx_Oe_SyncProtocol_FifoSize)count;
    dPipeStdif->write((void*)data, &c, 0);
    return count - c;
}


static inline sint32 Ifx_Oe_SyncProtocol_DPipeRead(Ifx_Oe_SyncProtocol_DPipeStdIf* dPipeStdif, void* data, sint32 count)
{
    Ifx_Oe_SyncProtocol_FifoSize c = (Ifx_Oe_SyncProtocol_FifoSize)count;
    dPipeStdif->read((void*)data, &c, 0);
    return count - c;
}


static inline sint32 Ifx_Oe_SyncProtocol_fifoWrite(Ifx_Oe_SyncProtocol_Fifo* fifo, const void* data, sint32 count)
{
    return fifo->write(data, count, 0);
}


/**
 * @return Return the number of bytes not read
 */
static inline sint32 Ifx_Oe_SyncProtocol_fifoRead(Ifx_Oe_SyncProtocol_Fifo* fifo, void* data, sint32 count)
{
    return fifo->read(data, count, 0);
}


static inline sint32 Ifx_Oe_SyncProtocol_fifoRemove(Ifx_Oe_SyncProtocol_Fifo* fifo, sint32 count)
{
    return fifo->remove(count);
}


static inline sint32 Ifx_Oe_SyncProtocol_fifoSize(Ifx_Oe_SyncProtocol_Fifo* fifo)
{
    return fifo->size();
}


static inline sint32 Ifx_Oe_SyncProtocol_canWriteCount(Ifx_Oe_SyncProtocol_Fifo* fifo, sint32 count)
{
    return fifo->canWriteCount(count, 0);
}


static inline bool Ifx_Oe_SyncProtocol_fifoIsEmpty(Ifx_Oe_SyncProtocol_Fifo* fifo)
{
    return fifo->isEmpty();
}


static inline bool Ifx_Oe_SyncProtocol_fifoIsFull(Ifx_Oe_SyncProtocol_Fifo* fifo)
{
    return fifo->isFull();
}


static inline char* Ifx_Oe_SyncProtocol_startDataPointer(Ifx_Oe_SyncProtocol_Fifo* fifo)
{
    return fifo->startDataPointer();
}


static inline char* Ifx_Oe_SyncProtocol_endDataPointer(Ifx_Oe_SyncProtocol_Fifo* fifo)
{
    return fifo->endDataPointer();
}


#elif IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_AURIX

static inline sint32 Ifx_Oe_SyncProtocol_DPipeWrite(Ifx_Oe_SyncProtocol_DPipeStdIf* dPipeStdif, const void* data, sint32 count)
{
    Ifx_Oe_SyncProtocol_FifoSize c = (Ifx_Oe_SyncProtocol_FifoSize)count;
    IfxStdIf_DPipe_write(dPipeStdif, (void*)data, &c, 0);
    return count - c;
}


static inline sint32 Ifx_Oe_SyncProtocol_DPipeRead(Ifx_Oe_SyncProtocol_DPipeStdIf* dPipeStdif, void* data, sint32 count)
{
    Ifx_Oe_SyncProtocol_FifoSize c = (Ifx_Oe_SyncProtocol_FifoSize)count;
    IfxStdIf_DPipe_read(dPipeStdif, (void*)data, &c, 0);
    return count - c;
}


static inline sint32 Ifx_Oe_SyncProtocol_fifoWrite(Ifx_Oe_SyncProtocol_Fifo* fifo, const void* data, sint32 count)
{
    return Ifx_Oe_Fifo_write(fifo, data, (Ifx_Oe_SizeT)count, 0);
}


static inline sint32 Ifx_Oe_SyncProtocol_fifoRead(Ifx_Oe_SyncProtocol_Fifo* fifo, void* data, sint32 count)
{
    return Ifx_Oe_Fifo_read(fifo, data, (Ifx_Oe_SizeT)count, 0);
}


static inline sint32 Ifx_Oe_SyncProtocol_fifoRemove(Ifx_Oe_SyncProtocol_Fifo* fifo, sint32 count)
{
    return Ifx_Oe_Fifo_remove(fifo, (Ifx_Oe_SizeT)count);
}


static inline sint32 Ifx_Oe_SyncProtocol_fifoSize(Ifx_Oe_SyncProtocol_Fifo* fifo)
{
    return Ifx_Oe_Fifo_size(fifo);
}


static inline sint32 Ifx_Oe_SyncProtocol_fifoCanWriteCount(Ifx_Oe_SyncProtocol_Fifo* fifo, sint32 count)
{
    return Ifx_Oe_Fifo_canWriteCount(fifo, (Ifx_Oe_SizeT)count, 0);
}


static inline boolean Ifx_Oe_SyncProtocol_fifoIsEmpty(Ifx_Oe_SyncProtocol_Fifo* fifo)
{
    return Ifx_Oe_Fifo_isEmpty(fifo);
}


static inline boolean Ifx_Oe_SyncProtocol_fifoIsFull(Ifx_Oe_SyncProtocol_Fifo* fifo)
{
    return Ifx_Oe_Fifo_isFull(fifo);
}


static inline char* Ifx_Oe_SyncProtocol_startDataPointer(Ifx_Oe_SyncProtocol_Fifo* fifo)
{
    return Ifx_Oe_Fifo_startDataPointer(fifo);
}


static inline char* Ifx_Oe_SyncProtocol_endDataPointer(Ifx_Oe_SyncProtocol_Fifo* fifo)
{
    return Ifx_Oe_Fifo_endDataPointer(fifo);
}


#endif

/*-------------------------------------------------------------------------*/
/* Ifx_Oe_SyncProtocol: Client server API                                         */
/*-------------------------------------------------------------------------*/
Ifx_Oe_SyncProtocol_FifoSize Ifx_Oe_SyncProtocol_getFifoSize(void)
{
    return IFX_OE_SYNCPROTOCOL_FIFO_SIZE;
}


void Ifx_Oe_SyncProtocol_init(Ifx_Oe_SyncProtocol* protocol, sint32 timeout, Ifx_Oe_SyncProtocol_DPipeStdIf* streamStdif)
{
    Ifx_Oe_SyncProtocol_Port port;
    IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_init [%1]").arg((uint64)protocol, 0, 16));
    ASSERT(IFX_OE_SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH > IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE); /* When a message should be send, a the frame payload should at least fit the message header  */
    ASSERT(IFX_OE_SYNCPROTOCOL_PORT_MAX < IFX_OE_SYNCPROTOCOL_PORT_NONE);

#if IFX_OE_SYNCPROTOCOL_USE_PRIVATE_HEAP != 0
    void* memoryPoolAdress = malloc(IFX_OE_SYNCPROTOCOL_PRIVATE_HEAP_SIZE);
    ASSERT(memoryPoolAdress != NULL);
    protocol->memoryPool = Ifx_Oe_Malloc_create(memoryPoolAdress, IFX_OE_SYNCPROTOCOL_PRIVATE_HEAP_SIZE);
    ASSERT(protocol->memoryPool != NULL);
#endif

#if IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_QT
    protocol->timeout     = timeout;    /* Should be longer than the frame  (IFX_OE_SYNCPROTOCOL_FRAME_HEADER_SIZE*3 + IFX_OE_SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH + 1) + repeat in case of error */
#elif IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_AURIX
    protocol->timeout     = Ifx_Oe_Time_getTickForMilliseconds(timeout);    /* Should be longer than the frame  (IFX_OE_SYNCPROTOCOL_FRAME_HEADER_SIZE*3 + IFX_OE_SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH + 1) + repeat in case of error */
#endif
    protocol->streamOwner = streamStdif == NULL;

    if (protocol->streamOwner)
    {
#if IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_QT
        protocol->stream      = new FifoDPipe(Ifx_Oe_SyncProtocol_getFifoSize(), Ifx_Oe_SyncProtocol_getFifoSize());
        protocol->streamStdif = protocol->stream;
#elif IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_AURIX
        protocol->stream      = Ifx_Oe_FifoDPipe_create(Ifx_Oe_SyncProtocol_getFifoSize(), Ifx_Oe_SyncProtocol_getFifoSize());
        protocol->streamStdif = &protocol->stream->stdif;
#endif
    }
    else
    {
        protocol->stream      = IFX_OE_SYNCPROTOCOL_NULL;
        protocol->streamStdif = streamStdif;
    }

    /* Assume clean synchornized startup */
    protocol->synchronized                          = TRUE;
    protocol->frameIndex                            = IFX_OE_SYNCPROTOCOL_FRAME_INDEX_INVALID;

    protocol->status.invalidAckFrameIndex           = 0;
    protocol->status.invalidAckStatus               = 0;
    protocol->status.invalidFrameIndex              = 0;
    protocol->status.invalidHeader                  = 0;
    protocol->status.pendingAckOverflow             = 0;
    protocol->status.portClosed                     = 0;
    protocol->status.portBusy                       = 0;
    protocol->status.invalidStartByte               = 0;
    protocol->status.payloadError                   = 0;
    protocol->status.receiveTimeout                 = 0;
    protocol->status.sendTimeout                    = 0;

    protocol->send.state                            = Ifx_Oe_SyncProtocol_SendState_readyForSend;

    protocol->send.header.startByte                 = IFX_OE_SYNCPROTOCOL_HEADER_START_BYTE;
    protocol->send.header.sender                    = IFX_OE_SYNCPROTOCOL_PORT_NONE;
    protocol->send.header.receiver                  = IFX_OE_SYNCPROTOCOL_PORT_NONE;
    protocol->send.header.flags.U                   = 0;
    protocol->send.header.checksumHeader            = 0;
    protocol->send.header.length                    = 0;
    protocol->send.header.checksumPayload           = 0;
    protocol->send.frameHeaderByteIndex             = 0;
    protocol->send.headerAckReceived                = Ifx_Oe_SyncProtocol_Ack_none;
    protocol->send.framePayloadByteIndex            = 0;
    protocol->send.payloadAckReceived               = Ifx_Oe_SyncProtocol_Ack_none;
    protocol->send.currentClient                    = NULL;
    protocol->send.pendingAckStatus                 = Ifx_Oe_SyncProtocol_Ack_none;
    protocol->send.pendingAckFrameIndex             = IFX_OE_SYNCPROTOCOL_FRAME_INDEX_INVALID;
    protocol->send.ackHeaderValid                   = FALSE;
    protocol->send.ackHeader.startByte              = IFX_OE_SYNCPROTOCOL_HEADER_START_BYTE;
    protocol->send.ackHeader.sender                 = IFX_OE_SYNCPROTOCOL_PORT_CORE;
    protocol->send.ackHeader.receiver               = IFX_OE_SYNCPROTOCOL_PORT_CORE;
    protocol->send.ackHeader.flags.U                = 0;
    protocol->send.ackHeader.flags.B.frameType      = Ifx_Oe_SyncProtocol_FrameType_ack;
    protocol->send.ackHeader.checksumHeader         = 0;
    protocol->send.ackHeader.length                 = 0;
    protocol->send.ackHeader.checksumPayload        = 0;
    protocol->send.ackHeaderByteIndex               = 0;

    protocol->receive.state                         = Ifx_Oe_SyncProtocol_ReceiveState_waitingForHeader;
    protocol->receive.header.startByte              = (uint8) ~IFX_OE_SYNCPROTOCOL_HEADER_START_BYTE;
    protocol->receive.header.sender                 = IFX_OE_SYNCPROTOCOL_PORT_NONE;
    protocol->receive.header.receiver               = IFX_OE_SYNCPROTOCOL_PORT_NONE;
    protocol->receive.header.flags.U                = 0;
    protocol->receive.header.checksumHeader         = 0;
    protocol->receive.header.length                 = 0;
    protocol->receive.header.checksumPayload        = 0;
    protocol->receive.payloadHeader.startByte       = IFX_OE_SYNCPROTOCOL_HEADER_START_BYTE;
    protocol->receive.payloadHeader.sender          = IFX_OE_SYNCPROTOCOL_PORT_NONE;
    protocol->receive.payloadHeader.receiver        = IFX_OE_SYNCPROTOCOL_PORT_NONE;
    protocol->receive.payloadHeader.flags.U         = 0;
    protocol->receive.payloadHeader.checksumHeader  = 0;
    protocol->receive.payloadHeader.length          = 0;
    protocol->receive.payloadHeader.checksumPayload = 0;
    protocol->receive.frameHeaderByteIndex          = 0;
    protocol->receive.framePayloadByteIndex         = 0;
    protocol->receive.lastValidFrameIndex           = IFX_OE_SYNCPROTOCOL_FRAME_INDEX_INVALID;

    for (port = 0; port <= IFX_OE_SYNCPROTOCOL_PORT_MAX; port++)
    {
        protocol->clients[port] = NULL;
    }

    /* Add core as a client */
    protocol->coreLock          = FALSE;
    Ifx_Oe_SyncProtocol_addClient(protocol, &protocol->core, IFX_OE_SYNCPROTOCOL_PORT_CORE, IFX_OE_SYNCPROTOCOL_PORT_CORE, IFX_OE_SYNCPROTOCOL_CORE_MESSAGE_PAYLOAD_MAX_LENGTH, 1);
    protocol->coreLock          = TRUE;
    protocol->waitingForPayload = FALSE;
}


void Ifx_Oe_SyncProtocol_deinit(Ifx_Oe_SyncProtocol* protocol)
{
    Ifx_Oe_SyncProtocol_Port port;
    IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_deinit [%1]").arg((uint64)protocol, 0, 16));
    protocol->coreLock = FALSE;

    for (port = 0; port <= IFX_OE_SYNCPROTOCOL_PORT_MAX; port++)
    {
        Ifx_Oe_SyncProtocol_removeClient(protocol->clients[port]);
    }

    protocol->coreLock = TRUE;

    if (protocol->streamOwner)
    {
#if IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_QT
        delete protocol->stream;
#elif IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_AURIX
        Ifx_Oe_FifoDPipe_destroy(protocol->stream);
#endif
        protocol->stream      = IFX_OE_SYNCPROTOCOL_NULL;
        protocol->streamStdif = IFX_OE_SYNCPROTOCOL_NULL;
    }

#if IFX_OE_SYNCPROTOCOL_USE_PRIVATE_HEAP != 0

    if (protocol->memoryPool != NULL)
    {
        Ifx_Oe_Malloc_destroy(protocol->memoryPool);
        free(protocol->memoryPool);
        protocol->memoryPool = NULL;
    }

#endif
}


boolean Ifx_Oe_SyncProtocol_addClient(Ifx_Oe_SyncProtocol* protocol, Ifx_Oe_SyncProtocol_Client* client, Ifx_Oe_SyncProtocol_Port localPort, Ifx_Oe_SyncProtocol_Port remotePort, uint32 receiveMessagePayloadSize, Ifx_Oe_SyncProtocol_FifoSize transmitBufferLength)
{
    if (localPort > IFX_OE_SYNCPROTOCOL_PORT_MAX)
    {
        return FALSE; /* ClientId too big */
    }
    else if (localPort == IFX_OE_SYNCPROTOCOL_PORT_NONE)
    {
        return FALSE; /* IFX_OE_SYNCPROTOCOL_PORT_NONE is not a client */
    }
    else if (remotePort == IFX_OE_SYNCPROTOCOL_PORT_NONE)
    {
        return FALSE; /* IFX_OE_SYNCPROTOCOL_PORT_NONE is not a client */
    }
    else if ((localPort == IFX_OE_SYNCPROTOCOL_PORT_CORE) && protocol->coreLock)
    {
        return FALSE; /* Core port is reserved */
    }
    else if ((remotePort == IFX_OE_SYNCPROTOCOL_PORT_CORE) && protocol->coreLock)
    {
        return FALSE; /* Core port is reserved */
    }

    /* Check if the ClientId is in use */
    if (!protocol->clients[localPort])
    {
        IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_addClient [%1]: localPort=%2, remotePort=%3").arg((uint64)protocol, 0, 16).arg(localPort).arg(remotePort));
        /* Initialize the client */
        client->protocol                  = protocol;
        client->localPort                 = localPort;
        client->remotePort                = remotePort;
        client->send.messageSendError     = FALSE;
        client->send.messageHeader.length = 0;
        client->send.messageHeader.id     = 0;
        client->send.messageHeader.dummy  = 0;
        client->send.messageByteIndex     = 0;
        client->send.messageDropCounter   = 0;

        ASSERT(transmitBufferLength > 0);
        Ifx_Oe_SyncProtocol_FifoSize size = transmitBufferLength * sizeof(Ifx_Oe_SyncProtocol_Message);
#if IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_QT
        client->send.buffer = new Fifo(size, sizeof(Ifx_Oe_SyncProtocol_Message));
#elif IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_AURIX
        client->send.buffer = Ifx_Oe_Fifo_create(size, sizeof(Ifx_Oe_SyncProtocol_Message));
#endif
        ASSERT(client->send.buffer != NULL);

        /* Need to have Ifx_Oe_SyncProtocol_Message elements not wrapped at the end of the buffer */
        ASSERT(Ifx_Oe_SyncProtocol_fifoSize(client->send.buffer) == size);
        client->send.currentMessage              = NULL;

        client->receive.messageValid             = FALSE;
        client->receive.messageHeader.length     = 0;
        client->receive.messageHeader.id         = 0;
        client->receive.messageHeader.dummy      = 0;
        client->receive.messagePayload           = (uint8*)Ifx_Oe_SyncProtocol_malloc(protocol->memoryPool, receiveMessagePayloadSize);
        ASSERT(client->receive.messagePayload != NULL);
        client->receive.messagePayloadBufferSize = receiveMessagePayloadSize;
        client->receive.messageByteIndex         = 0;
        protocol->clients[localPort]             = client;
        return client->send.buffer != NULL;
    }
    else
    {
        IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_addClient [%1]: Already available, localPort=%2, remotePort=%3").arg((uint64)protocol, 0, 16).arg(localPort).arg(remotePort));
        return protocol->clients[localPort] == client;
    }
}


/**
 * @brief Remove the next message from the client send buffer
 *
 * @param client
 *
 * Note: the buffer shall not be empty
 */
static void Ifx_Oe_SyncProtocol_removeNextSendMessageFromBuffer(Ifx_Oe_SyncProtocol_Client* client)
{
    ASSERT(!Ifx_Oe_SyncProtocol_fifoIsEmpty(client->send.buffer));

    Ifx_Oe_SyncProtocol_Message* message = (Ifx_Oe_SyncProtocol_Message*)Ifx_Oe_SyncProtocol_startDataPointer(client->send.buffer);

    if (message->messagePayload != NULL)
    {
        Ifx_Oe_SyncProtocol_free(message->messagePayload);
    }

    /* Remove message from the buffer */
    Ifx_Oe_SyncProtocol_fifoRemove(client->send.buffer, sizeof(Ifx_Oe_SyncProtocol_Message));
}


boolean Ifx_Oe_SyncProtocol_removeClient(Ifx_Oe_SyncProtocol_Client* client)
{
    if (client
        && (client->protocol != NULL)
        && (client->localPort <= IFX_OE_SYNCPROTOCOL_PORT_MAX)
        && ((client->localPort > IFX_OE_SYNCPROTOCOL_PORT_CORE) || !client->protocol->coreLock)
        && (!Ifx_Oe_SyncProtocol_isSendBusy(client))
        )
    {
        Ifx_Oe_SyncProtocol* protocol = client->protocol;

        IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_removeClient [%1]: localPort=%2").arg((uint64)client->protocol, 0, 16).arg(client->localPort));
        protocol->clients[client->localPort] = NULL;

        /* If a client is currently sending data, abort send operation */
        if (protocol->send.currentClient == client)
        {
            protocol->send.currentClient = NULL;
            protocol->send.state         = Ifx_Oe_SyncProtocol_SendState_readyForSend;
        }

        /* If a client is currently receiving data, abort receive operation */
        if ((protocol->receive.state == Ifx_Oe_SyncProtocol_ReceiveState_readingPayload)
            && (protocol->receive.payloadHeader.receiver == client->localPort))
        {
            protocol->receive.frameHeaderByteIndex = 0;
            protocol->waitingForPayload            = FALSE;
            protocol->receive.state                = Ifx_Oe_SyncProtocol_ReceiveState_waitingForHeader;
        }

        /* Remove buffered items */
        while (!Ifx_Oe_SyncProtocol_fifoIsEmpty(client->send.buffer))
        {
            Ifx_Oe_SyncProtocol_removeNextSendMessageFromBuffer(client);
            client->send.messageDropCounter++;
        }

#if IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_QT
        delete client->send.buffer;
#elif IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_AURIX
        Ifx_Oe_Fifo_destroy(client->send.buffer);
#endif
        client->send.buffer = NULL;
        Ifx_Oe_SyncProtocol_free(client->receive.messagePayload);
        client->protocol    = NULL;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


static void Ifx_Oe_SyncProtocol_freeCurrentSendMessage(Ifx_Oe_SyncProtocol_Client* client)
{
    /* Check that there is a current message */
    ASSERT(client->send.currentMessage != NULL);
    /* Check that it is matching with the buffer state */
    ASSERT(client->send.currentMessage == (Ifx_Oe_SyncProtocol_Message*)Ifx_Oe_SyncProtocol_startDataPointer(client->send.buffer));

    Ifx_Oe_SyncProtocol_removeNextSendMessageFromBuffer(client);

    /* Mark the client as not being sending message */
    client->send.currentMessage = NULL;
}


static void Ifx_Oe_SyncProtocol_printMessageInfo(Ifx_Oe_SyncProtocol_Message* message, const char* info)
{
    if (message->messagePayload != NULL)
    {
        if (message->dataLength <= 5)
        {
            IFX_OE_SYNCPROTOCOL_WARNING(
                QString("PProtocol_Bb: Data with message ID %1 and length %2 %3: %4")
                .arg(message->id)
                .arg(message->dataLength)
                .arg(info)
                .arg(QString::fromLocal8Bit((char*)message->messagePayload, message->dataLength)));
        }
        else
        {
            IFX_OE_SYNCPROTOCOL_WARNING(
                QString("PProtocol_Bb: Data with message ID %1 and length %2 %3: %4...")
                .arg(message->id)
                .arg(message->dataLength)
                .arg(info)
                .arg(QString::fromLocal8Bit((char*)message->messagePayload, 5)));
        }
    }
    else
    {
        IFX_OE_SYNCPROTOCOL_WARNING(
            QString("PProtocol_Bb: Data with message ID %1 and length 0 %2")
            .arg(message->id)
            .arg(info));
    }
}


static void Ifx_Oe_SyncProtocol_processSendBuffers(Ifx_Oe_SyncProtocol* protocol)
{
    Ifx_Oe_SyncProtocol_Port port;

    for (port = 0; port <= IFX_OE_SYNCPROTOCOL_PORT_MAX; port++)
    {
        Ifx_Oe_SyncProtocol_Client* client = protocol->clients[port];

        if (
            /* Client not defined */
            (client == NULL)
            /* Client already busy sending */
            || Ifx_Oe_SyncProtocol_isSendBusy(client))
        {
            continue;
        }

        /* Items are sorted with increasing deadline
         */
        while (!Ifx_Oe_SyncProtocol_fifoIsEmpty(client->send.buffer))
        {
            Ifx_Oe_SyncProtocol_Message* message = (Ifx_Oe_SyncProtocol_Message*)Ifx_Oe_SyncProtocol_startDataPointer(client->send.buffer);

            if (!message->valid)
            {
                /* Invalid message are still beeing edited. Do nothing */
                break;
            }

            if (message->deadline == 0)
            {
                /* Message dropped. Remove from buffer */
                Ifx_Oe_SyncProtocol_removeNextSendMessageFromBuffer(client);
            }
            else if (message->deadline < IFX_OE_SYNCPROTOCOL_CURRENT_TIME)
            {
                /* Remove items that timed out */
                Ifx_Oe_SyncProtocol_printMessageInfo(message, "dropped");
                Ifx_Oe_SyncProtocol_removeNextSendMessageFromBuffer(client);
                client->send.messageDropCounter++;
            }
            else
            {
                /* Send next waiting item */
                client->send.messageHeader.id     = message->id;
                client->send.messageHeader.dummy  = 0;
                client->send.messageHeader.length = IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE + message->dataLength;
                client->send.messageByteIndex     = 0;
                client->send.messageSendError     = FALSE;

                client->send.currentMessage       = message;

                /* Initialize the message sending process  */
                IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processSendBuffers [%1]: localPort=0x%2, remotePort=%3, id=0x%4").arg((uint64)client->protocol, 0, 16).arg(client->localPort).arg(client->remotePort).arg(client->send.messageHeader.id, 0, 16));

                break;
            }
        }
    }
}


void Ifx_Oe_SyncProtocol_execute(Ifx_Oe_SyncProtocol* protocol)
{
    Ifx_Oe_SyncProtocol_processIncomming(protocol);

    Ifx_Oe_SyncProtocol_processSendBuffers(protocol);
    Ifx_Oe_SyncProtocol_processOutgoing(protocol);
}


static uint8 Ifx_Oe_SyncProtocol_calculateFrameHeaderChecksum(Ifx_Oe_SyncProtocol_FrameHeader* header)
{
    return 1
           + (
        header->startByte
        + header->sender
        + header->receiver
        + header->flags.X.b0
        + header->flags.X.b1
        + header->length
        + header->checksumPayload
        );
}


static uint8 Ifx_Oe_SyncProtocol_calculateFramePayloadChecksum(Ifx_Oe_SyncProtocol_FrameHeader* header, Ifx_Oe_SyncProtocol_MessageHeader* messageHeader, uint8* messagePayload)
{
    uint32 i;
    uint8  checksum = 0;

    if (messageHeader != NULL)
    {
        for (i = 0; i < IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE; i++)
        {
            checksum += ((uint8*)messageHeader)[i];
        }

        for (i = 0; i < header->length - IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE; i++)
        {
            checksum += messagePayload[i];
        }
    }
    else
    {
        for (i = 0; i < header->length; i++)
        {
            checksum += messagePayload[i];
        }
    }

    return 256 - checksum;
}


/*-------------------------------------------------------------------------*/
/* Ifx_Oe_SyncProtocol: Client send API                                           */
/*-------------------------------------------------------------------------*/

Ifx_Oe_SyncProtocol_Message* Ifx_Oe_SyncProtocol_setSendMessageBuffer(Ifx_Oe_SyncProtocol_Client* client, Ifx_Oe_SyncProtocol_MessageId id, uint32 payloadLength)
{
    if (id <= IFX_OE_SYNCPROTOCOL_MESSAGE_ID_RESERVED_BY_CORE)
    {
        /* Reserved ID */
        IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_setSendMessageBuffer [%1]: ERROR reserved ID : id=0x%2, length=%3").arg((uint64)client->protocol, 0, 16).arg(id, 0, 16).arg(payloadLength));
        return NULL;
    }
    else if (!Ifx_Oe_SyncProtocol_fifoIsFull(client->send.buffer))
    {
        Ifx_Oe_SyncProtocol_Message message;
        message.valid      = 0;
        message.reserved   = 0;
        message.id         = id;
        message.deadline   = IFX_OE_SYNCPROTOCOL_CURRENT_TIME + client->protocol->timeout;
        message.dataLength = payloadLength;

        if (payloadLength > 0)
        {
            message.messagePayload = (uint8*)Ifx_Oe_SyncProtocol_malloc(client->protocol->memoryPool, payloadLength); /* FIXME optimization: cache last(s) buffer address to avoid continuous malloc  */

            if (message.messagePayload == NULL)
            {
                ASSERT(FALSE);
                client->send.messageDropCounter++;
                return NULL;
            }
        }
        else
        {
            message.messagePayload = NULL;
        }

        Ifx_Oe_SyncProtocol_Message* data   = (Ifx_Oe_SyncProtocol_Message*)Ifx_Oe_SyncProtocol_endDataPointer(client->send.buffer);
        boolean                      result = Ifx_Oe_SyncProtocol_fifoWrite(client->send.buffer, &message, sizeof(message)) == 0;

        if (result)
        {
            IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_setSendMessageBuffer [%1]: id=0x%2, length=%3").arg((uint64)client->protocol, 0, 16).arg(id, 0, 16).arg(payloadLength));
            return data;
        }
        else
        {
            /* FIFO write should have succeed, FIFO was not full */
            ASSERT(FALSE);
            /* FIFO write error , clean up */
            IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_setSendMessageBuffer [%1]: ERROR buffer full: id=0x%2, length=%3").arg((uint64)client->protocol, 0, 16).arg(id, 0, 16).arg(payloadLength));
            client->send.messageDropCounter++;

            if (message.messagePayload != NULL)
            {
                Ifx_Oe_SyncProtocol_free(message.messagePayload);
            }

            return NULL;
        }
    }
    else
    {
        /* Buffer full */
        IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_setSendMessageBuffer [%1]: ERROR buffer full: id=0x%2, length=%3").arg((uint64)client->protocol, 0, 16).arg(id, 0, 16).arg(payloadLength));
        client->send.messageDropCounter++;
        return NULL;
    }
}


boolean Ifx_Oe_SyncProtocol_updatePayloadLength(Ifx_Oe_SyncProtocol_Message* message, uint32 payloadLength)
{
    IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_updatePayloadLength: id=0x%1, length=%2").arg(((Ifx_Oe_SyncProtocol_MessageHeader*)message)->id, 0, 16).arg(payloadLength));

    if (payloadLength == 0)
    {
        Ifx_Oe_SyncProtocol_free(message->messagePayload);
        message->messagePayload = NULL;
        message->dataLength     = payloadLength;
    }
    else
    {
        uint8* newPointer = (uint8*)Ifx_Oe_SyncProtocol_realloc(message->messagePayload, payloadLength);

        if (newPointer != NULL)
        {
            message->messagePayload = newPointer;
            message->dataLength     = payloadLength;
        }
        else
        {
            /* Memory allocation failed, keep old pointer  */
            return FALSE;
        }
    }

    return TRUE;
}


void Ifx_Oe_SyncProtocol_sendMessage(Ifx_Oe_SyncProtocol_Message* message)
{
    message->valid = 1;
}


void Ifx_Oe_SyncProtocol_dropMessage(Ifx_Oe_SyncProtocol_Message* message)
{
    /* Set deadline to 0 so that the message get discarded */
    message->valid    = 1;
    message->deadline = 0;
}


static uint8 Ifx_Oe_SyncProtocol_getNextIndex(uint8 currentIndex)
{
    currentIndex = (currentIndex + 1) & IFX_OE_SYNCPROTOCOL_FRAME_MAX_INDEX;

    if (currentIndex == 0)
    {
        currentIndex = 1;
    }

    return currentIndex;
}


static uint8 Ifx_Oe_SyncProtocol_getNewIndex(Ifx_Oe_SyncProtocol* protocol)
{
    return Ifx_Oe_SyncProtocol_getNextIndex(protocol->frameIndex);
}


static boolean Ifx_Oe_SyncProtocol_setAck(Ifx_Oe_SyncProtocol* protocol, Ifx_Oe_SyncProtocol_FrameHeader* header)
{
    boolean result;

    if (protocol->send.pendingAckStatus != Ifx_Oe_SyncProtocol_Ack_none)
    {
        header->flags.B.ack             = protocol->send.pendingAckStatus;
        header->flags.B.indexAck        = protocol->send.pendingAckFrameIndex;
        protocol->send.pendingAckStatus = Ifx_Oe_SyncProtocol_Ack_none;
        IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_setAck [%1]: ack=%2, frameIndex=%3").arg((uint64)protocol, 0, 16).arg(header->flags.B.ack).arg(header->flags.B.indexAck));
        result                          = TRUE;
    }
    else
    {
        header->flags.B.ack      = Ifx_Oe_SyncProtocol_Ack_none;
        header->flags.B.indexAck = IFX_OE_SYNCPROTOCOL_FRAME_INDEX_INVALID;
        result                   = FALSE;
    }

    return result;
}


static void Ifx_Oe_SyncProtocol_prepareFrame(Ifx_Oe_SyncProtocol* protocol)
{
    Ifx_Oe_SyncProtocol_Client*      client = protocol->send.currentClient;
    Ifx_Oe_SyncProtocol_FrameHeader* header = &protocol->send.header;

    ASSERT(protocol->send.currentClient != NULL);
    ASSERT(client->send.currentMessage != NULL);

    uint32 chunk;
    Ifx_Oe_SyncProtocol_setAck(protocol, header);
    header->sender   = client->localPort;
    header->receiver = client->remotePort;

    /* Fill header */
    chunk = client->send.messageHeader.length - client->send.messageByteIndex;

    if (chunk > IFX_OE_SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH)
    {
        if (client->send.messageByteIndex == 0)
        {
            header->flags.B.frameType = Ifx_Oe_SyncProtocol_FrameType_dataStart;
        }
        else
        {
            header->flags.B.frameType = Ifx_Oe_SyncProtocol_FrameType_dataMiddle;
        }

        header->length = IFX_OE_SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH;
    }
    else
    {
        if (client->send.messageHeader.length > IFX_OE_SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH)
        {
            header->flags.B.frameType = Ifx_Oe_SyncProtocol_FrameType_dataEnd;
        }
        else
        {
            header->flags.B.frameType = Ifx_Oe_SyncProtocol_FrameType_data;
        }

        header->length = (uint8)chunk;
    }

    header->flags.B.index = Ifx_Oe_SyncProtocol_getNewIndex(protocol);

    if (client->send.messageByteIndex == 0)
    {
        header->checksumPayload = Ifx_Oe_SyncProtocol_calculateFramePayloadChecksum(
            header,
            &client->send.messageHeader,
            &client->send.currentMessage->messagePayload[0]);
    }
    else
    {
        header->checksumPayload = Ifx_Oe_SyncProtocol_calculateFramePayloadChecksum(
            header,
            NULL,
            &client->send.currentMessage->messagePayload[client->send.messageByteIndex - IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE]);
    }

    header->checksumHeader = Ifx_Oe_SyncProtocol_calculateFrameHeaderChecksum(header);

    /* Prepare for send */
    protocol->send.frameHeaderByteIndex  = 0;
    protocol->send.headerAckReceived     = Ifx_Oe_SyncProtocol_Ack_none;
    protocol->send.framePayloadByteIndex = 0;
    protocol->send.payloadAckReceived    = Ifx_Oe_SyncProtocol_Ack_none;
    IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_prepareFrame [%1]: frameType=%2, frameIndex=%3, length=%4").arg((uint64)client->protocol, 0, 16).arg(header->flags.B.frameType).arg(header->flags.B.index).arg(header->length));
}


static boolean Ifx_Oe_SyncProtocol_sendPayload(Ifx_Oe_SyncProtocol* protocol)
{
    Ifx_Oe_SyncProtocol_Client*      client = protocol->send.currentClient;
    Ifx_Oe_SyncProtocol_FrameHeader* header = &protocol->send.header;

    ASSERT(protocol->send.currentClient != NULL);
    ASSERT(client->send.currentMessage != NULL);
    ASSERT(protocol->send.framePayloadByteIndex < header->length);
    ASSERT(header->length > 0);

    sint32  writeCount;
    boolean messageHeaderPresent = (header->flags.B.frameType == Ifx_Oe_SyncProtocol_FrameType_data) || (header->flags.B.frameType == Ifx_Oe_SyncProtocol_FrameType_dataStart);

    /* Send message header */
    writeCount = IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE - protocol->send.framePayloadByteIndex;

    if (messageHeaderPresent && (writeCount > 0))
    {
        writeCount                            = writeCount - Ifx_Oe_SyncProtocol_DPipeWrite(protocol->streamStdif, (void*)&((uint8*)&client->send.messageHeader)[client->send.messageByteIndex], writeCount);
        protocol->send.framePayloadByteIndex += (uint8)writeCount;
        client->send.messageByteIndex        += writeCount;
    }

    if (!messageHeaderPresent || (client->send.messageByteIndex >= IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE))
    {
        /* Send message payload */
        writeCount = header->length - protocol->send.framePayloadByteIndex;

        if (writeCount > 0)
        {
            writeCount                            = writeCount - Ifx_Oe_SyncProtocol_DPipeWrite(protocol->streamStdif, (void*)&client->send.currentMessage->messagePayload[client->send.messageByteIndex - IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE], writeCount);
            protocol->send.framePayloadByteIndex += (uint8)writeCount;
            client->send.messageByteIndex        += writeCount;
        }
    }

    return header->length == protocol->send.framePayloadByteIndex;
}


static boolean Ifx_Oe_SyncProtocol_checkPendingAck(Ifx_Oe_SyncProtocol* protocol)
{
    boolean result;
    ASSERT(
        (protocol->send.state == Ifx_Oe_SyncProtocol_SendState_readyForSend)
        || (protocol->send.state == Ifx_Oe_SyncProtocol_SendState_waitingForHeaderAck)
        || (protocol->send.state == Ifx_Oe_SyncProtocol_SendState_waitingForPayloadAck));

    if (protocol->send.pendingAckStatus != Ifx_Oe_SyncProtocol_Ack_none)
    {
        Ifx_Oe_SyncProtocol_FrameHeader* header = &protocol->send.ackHeader;

        IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_checkPendingAck [%1]: Sending Acknoledge").arg((uint64)protocol, 0, 16));
        Ifx_Oe_SyncProtocol_setAck(protocol, header);

        header->flags.B.index   = Ifx_Oe_SyncProtocol_getNewIndex(protocol);

        header->checksumPayload = Ifx_Oe_SyncProtocol_calculateFramePayloadChecksum(header, NULL, NULL);
        header->checksumHeader  = Ifx_Oe_SyncProtocol_calculateFrameHeaderChecksum(header);

        /* Prepare for send */
        protocol->send.ackHeaderByteIndex = 0;

        result                            = TRUE;
    }
    else
    {
        result = FALSE;
    }

    return result;
}


static void Ifx_Oe_SyncProtocol_processOutgoing(Ifx_Oe_SyncProtocol* protocol)
{
    Ifx_Oe_SyncProtocol_FrameHeader* header = &protocol->send.header;

    if (protocol->send.ackHeaderValid)
    {
        sint32 writeCount;
        writeCount = IFX_OE_SYNCPROTOCOL_FRAME_HEADER_SIZE - protocol->send.ackHeaderByteIndex;
        ASSERT(writeCount > 0);

        writeCount                         = writeCount - Ifx_Oe_SyncProtocol_DPipeWrite(protocol->streamStdif, (void*)&((uint8*)&protocol->send.ackHeader)[protocol->send.ackHeaderByteIndex], writeCount);
        protocol->send.ackHeaderByteIndex += (uint8)writeCount;

        if (protocol->send.ackHeaderByteIndex == IFX_OE_SYNCPROTOCOL_FRAME_HEADER_SIZE)
        {
            IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processOutgoing [%1]: Ack header send : frameType=%2, frameIndex=%3, length=%4").arg((uint64)protocol, 0, 16).arg(protocol->send.ackHeader.flags.B.frameType).arg(protocol->send.ackHeader.flags.B.index).arg(protocol->send.ackHeader.length));
            protocol->send.ackHeaderValid = FALSE;
        }
    }
    /* If an header is currently beeing send, continue sending */
    else if (protocol->send.state == Ifx_Oe_SyncProtocol_SendState_readyForSend)
    {
        ASSERT(protocol->send.currentClient == NULL);

        /* Check if a client is waiting for send, enable it */
        Ifx_Oe_SyncProtocol_Port port;

        for (port = 0; port <= IFX_OE_SYNCPROTOCOL_PORT_MAX; port++)
        {
            Ifx_Oe_SyncProtocol_Client* client = protocol->clients[port];

            if (client != NULL)
            {
                if (client->send.currentMessage != NULL)
                {
                    protocol->send.currentClient = client;
                    protocol->send.state         = Ifx_Oe_SyncProtocol_SendState_prepareFrame;
                    IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processOutgoing [%1]: Client mark for send : localPort=%2").arg((uint64)protocol, 0, 16).arg(client->localPort));
                    break;
                }
            }
        }

        if ((protocol->send.currentClient == NULL) && Ifx_Oe_SyncProtocol_checkPendingAck(protocol))
        {
            protocol->send.ackHeaderValid     = TRUE;
            protocol->send.ackHeaderByteIndex = 0;
        }
    }
    else if (protocol->send.state == Ifx_Oe_SyncProtocol_SendState_prepareFrame)
    {
        Ifx_Oe_SyncProtocol_prepareFrame(protocol);
        protocol->send.state    = Ifx_Oe_SyncProtocol_SendState_sendingHeader;
        protocol->send.deadline = IFX_OE_SYNCPROTOCOL_CURRENT_TIME + protocol->timeout;
    }
    else if (protocol->send.deadline <= IFX_OE_SYNCPROTOCOL_CURRENT_TIME)
    {
        protocol->status.sendTimeout++;
        Ifx_Oe_SyncProtocol_freeCurrentSendMessage(protocol->send.currentClient);
        protocol->send.currentClient->send.messageSendError = TRUE;
        protocol->send.currentClient                        = NULL;
        protocol->send.state                                = Ifx_Oe_SyncProtocol_SendState_readyForSend;
        IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processOutgoing [%1]: Send timeout").arg((uint64)protocol, 0, 16));
    }
    else if (protocol->send.state == Ifx_Oe_SyncProtocol_SendState_sendingHeader)
    {
        sint32 writeCount;
        writeCount = IFX_OE_SYNCPROTOCOL_FRAME_HEADER_SIZE - protocol->send.frameHeaderByteIndex;
        ASSERT(writeCount > 0);

        writeCount                           = writeCount - Ifx_Oe_SyncProtocol_DPipeWrite(protocol->streamStdif, (void*)&((uint8*)&protocol->send.header)[protocol->send.frameHeaderByteIndex], writeCount);
        protocol->send.frameHeaderByteIndex += (uint8)writeCount;

        if (protocol->send.frameHeaderByteIndex == IFX_OE_SYNCPROTOCOL_FRAME_HEADER_SIZE)
        {
            IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processOutgoing [%1]: Header send : frameType=%2, frameIndex=%3, length=%4").arg((uint64)protocol, 0, 16).arg(protocol->send.header.flags.B.frameType).arg(protocol->send.header.flags.B.index).arg(protocol->send.header.length));
            protocol->send.headerAckReceived = Ifx_Oe_SyncProtocol_Ack_none; /* FIXME might not be required */
            protocol->send.state             = Ifx_Oe_SyncProtocol_SendState_waitingForHeaderAck;
        }
    }
    else if (protocol->send.state == Ifx_Oe_SyncProtocol_SendState_waitingForHeaderAck)
    {
        if (protocol->send.headerAckReceived == Ifx_Oe_SyncProtocol_Ack_headerOk)
        {
            IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processOutgoing [%1]: Ack OK received :").arg((uint64)protocol, 0, 16));
            protocol->send.state = header->length == 0 ? Ifx_Oe_SyncProtocol_SendState_readyForSend : Ifx_Oe_SyncProtocol_SendState_sendingPayloadStartByte;
        }
        else if (
            (protocol->send.headerAckReceived == Ifx_Oe_SyncProtocol_Ack_busy)
            || (protocol->send.headerAckReceived == Ifx_Oe_SyncProtocol_Ack_portClosed))
        {
            /* Cancel payload send */
            IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processOutgoing [%1]: Ack %2 received, aborting :").arg((uint64)protocol, 0, 16).arg(protocol->send.headerAckReceived));
            protocol->send.state                                = Ifx_Oe_SyncProtocol_SendState_readyForSend;
            Ifx_Oe_SyncProtocol_freeCurrentSendMessage(protocol->send.currentClient);
            protocol->send.currentClient->send.messageSendError = TRUE;
            protocol->send.currentClient                        = NULL;
        }
        else if (protocol->send.headerAckReceived == Ifx_Oe_SyncProtocol_Ack_headerError)
        {
            /* re-send header */
            IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processOutgoing [%1]: Ack ERROR received, re-sending :").arg((uint64)protocol, 0, 16));
            protocol->send.state                = Ifx_Oe_SyncProtocol_SendState_sendingHeader;
            protocol->send.headerAckReceived    = Ifx_Oe_SyncProtocol_Ack_none;
            protocol->send.frameHeaderByteIndex = 0;
        }
        else if (Ifx_Oe_SyncProtocol_checkPendingAck(protocol))
        {
            protocol->send.ackHeaderValid     = TRUE;
            protocol->send.ackHeaderByteIndex = 0;
        }
    }
    /* If a client frame is currently beeing send, continue sending */
    else if (protocol->send.state == Ifx_Oe_SyncProtocol_SendState_sendingPayloadStartByte)
    {
        sint32 writeCount;
        uint8  data = IFX_OE_SYNCPROTOCOL_PAYLOAD_START_BYTE;
        writeCount = 1;

        writeCount = writeCount - Ifx_Oe_SyncProtocol_DPipeWrite(protocol->streamStdif, (void*)&data, writeCount);

        if (writeCount == 1)
        {
            IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processOutgoing [%1]: Payload start byte send :").arg((uint64)protocol, 0, 16));
            protocol->send.state = Ifx_Oe_SyncProtocol_SendState_sendingPayload;
        }
    }
    else if (protocol->send.state == Ifx_Oe_SyncProtocol_SendState_sendingPayload)
    {
        if (Ifx_Oe_SyncProtocol_sendPayload(protocol))
        {
            IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processOutgoing [%1]: Payload send :").arg((uint64)protocol, 0, 16));
            protocol->send.state = Ifx_Oe_SyncProtocol_SendState_waitingForPayloadAck;
        }
    }
    else if (protocol->send.state == Ifx_Oe_SyncProtocol_SendState_waitingForPayloadAck)
    {
        if (protocol->send.payloadAckReceived == Ifx_Oe_SyncProtocol_Ack_payloadOk)
        {
            IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processOutgoing [%1]: Payload ACK OK received :").arg((uint64)protocol, 0, 16));
            protocol->send.state = Ifx_Oe_SyncProtocol_SendState_readyForSend;

            if ((header->flags.B.frameType == Ifx_Oe_SyncProtocol_FrameType_data)
                || (header->flags.B.frameType == Ifx_Oe_SyncProtocol_FrameType_dataEnd))
            {
                Ifx_Oe_SyncProtocol_freeCurrentSendMessage(protocol->send.currentClient);
            }

            protocol->send.currentClient = NULL;
        }
        else if (protocol->send.payloadAckReceived == Ifx_Oe_SyncProtocol_Ack_payloadError)
        {
            /* re-send payload */
            IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processOutgoing [%1]: Payload ACK ERROR received, resend :").arg((uint64)protocol, 0, 16));
            protocol->send.state                                 = Ifx_Oe_SyncProtocol_SendState_sendingPayloadStartByte;
            protocol->send.payloadAckReceived                    = Ifx_Oe_SyncProtocol_Ack_none;
            protocol->send.currentClient->send.messageByteIndex -= protocol->send.framePayloadByteIndex;
            protocol->send.framePayloadByteIndex                 = 0;
        }
        else if (Ifx_Oe_SyncProtocol_checkPendingAck(protocol))
        {
            protocol->send.ackHeaderValid     = TRUE;
            protocol->send.ackHeaderByteIndex = 0;
        }
    }
}


/*-------------------------------------------------------------------------*/
/* Ifx_Oe_SyncProtocol: Client receive API                                           */
/*-------------------------------------------------------------------------*/
static void Ifx_Oe_SyncProtocol_raiseAck(Ifx_Oe_SyncProtocol* protocol, uint8 frameIndex, uint8 ackStatus)
{
    if (protocol->send.pendingAckStatus != Ifx_Oe_SyncProtocol_Ack_none)
    {
        protocol->status.pendingAckOverflow++;
    }

    IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_raiseAck [%1]: pendingAckStatus=%2, pendingAckFrameIndex=%3").arg((uint64)protocol, 0, 16).arg(ackStatus).arg(frameIndex));
    protocol->send.pendingAckStatus     = ackStatus;
    protocol->send.pendingAckFrameIndex = frameIndex;
}


boolean Ifx_Oe_SyncProtocol_getReadMessageBuffer(Ifx_Oe_SyncProtocol_Client* client, Ifx_Oe_SyncProtocol_MessageId* id, uint8** messagePayload, uint32* payloadLength)
{
    boolean result;

    if (client->receive.messageValid)
    {
        IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_getReadMessageBuffer [%1]: localPort=%2").arg((uint64)client->protocol, 0, 16).arg(client->localPort));
        *messagePayload = client->receive.messagePayload;
        *id             = client->receive.messageHeader.id;
        *payloadLength  = client->receive.messageHeader.length - IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE;
        result          = TRUE;
    }
    else
    {
        result = FALSE;
    }

    return result;
}


void Ifx_Oe_SyncProtocol_releaseReadMessageBuffer(Ifx_Oe_SyncProtocol_Client* client)
{
    IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_releaseReadMessageBuffer [%1]: localPort=%2").arg((uint64)client->protocol, 0, 16).arg(client->localPort));
    client->receive.messageValid = FALSE;
}


static void Ifx_Oe_SyncProtocol_processAck(Ifx_Oe_SyncProtocol* protocol, Ifx_Oe_SyncProtocol_FrameHeader* header)
{
    if (protocol->send.header.flags.B.index != IFX_OE_SYNCPROTOCOL_FRAME_INDEX_INVALID)
    {
        if (protocol->send.header.flags.B.index == header->flags.B.indexAck)
        {
            if (protocol->send.state == Ifx_Oe_SyncProtocol_SendState_waitingForHeaderAck)
            {
                IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processAck [%1]: ack=%2").arg((uint64)protocol, 0, 16).arg(header->flags.B.ack));
                protocol->send.headerAckReceived = header->flags.B.ack;
            }
            else if (protocol->send.state == Ifx_Oe_SyncProtocol_SendState_waitingForPayloadAck)
            {
                IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processAck [%1]: ack=%2").arg((uint64)protocol, 0, 16).arg(header->flags.B.ack));
                protocol->send.payloadAckReceived = header->flags.B.ack;
            }
        }
        else
        {
            protocol->status.invalidAckFrameIndex++;
        }
    }
}


static void Ifx_Oe_SyncProtocol_readHeader(Ifx_Oe_SyncProtocol* protocol)
{
    ASSERT(protocol->receive.state == Ifx_Oe_SyncProtocol_ReceiveState_waitingForHeader);
    sint32                           readCount = 1;
    Ifx_Oe_SyncProtocol_FrameHeader* header    = &protocol->receive.header;

    while ((readCount == 1) && protocol->receive.frameHeaderByteIndex == 0)
    {
        readCount = readCount - Ifx_Oe_SyncProtocol_DPipeRead(protocol->streamStdif, &header->startByte, readCount);

        if ((readCount == 1) && (header->startByte == IFX_OE_SYNCPROTOCOL_HEADER_START_BYTE))
        {
            IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_readHeader [%1]: Header start byte received :").arg((uint64)protocol, 0, 16));
            protocol->receive.frameHeaderByteIndex = 1;
        }
    }

    /* Read the full header */
    if (protocol->receive.frameHeaderByteIndex > 0)
    {
        readCount                               = IFX_OE_SYNCPROTOCOL_FRAME_HEADER_SIZE - protocol->receive.frameHeaderByteIndex;
        readCount                               = readCount - Ifx_Oe_SyncProtocol_DPipeRead(protocol->streamStdif, (void*)&((uint8*)header)[protocol->receive.frameHeaderByteIndex], readCount);
        protocol->receive.frameHeaderByteIndex += (uint8)readCount;

        /* Check the header */
        if (protocol->receive.frameHeaderByteIndex == IFX_OE_SYNCPROTOCOL_FRAME_HEADER_SIZE)
        {
            if (header->checksumHeader == Ifx_Oe_SyncProtocol_calculateFrameHeaderChecksum(header))
            {
                protocol->receive.deadline            = IFX_OE_SYNCPROTOCOL_CURRENT_TIME + protocol->timeout;
                IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_readHeader [%1]: Header received : frameIndex=%2, sender=%3, receiver=%4").arg((uint64)protocol, 0, 16).arg(header->flags.B.index).arg(header->sender).arg(header->receiver));
                protocol->synchronized                = TRUE;
                protocol->receive.lastValidFrameIndex = header->flags.B.index;
                Ifx_Oe_SyncProtocol_Client* client = protocol->clients[header->receiver];

                if ((header->receiver > IFX_OE_SYNCPROTOCOL_PORT_MAX) || (client == NULL)
                    || (header->length > IFX_OE_SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH)
                    || (((header->flags.B.frameType == Ifx_Oe_SyncProtocol_FrameType_data) || (header->flags.B.frameType == Ifx_Oe_SyncProtocol_FrameType_dataStart)) && (header->length - IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE > client->receive.messagePayloadBufferSize))
                    || (((header->flags.B.frameType == Ifx_Oe_SyncProtocol_FrameType_dataMiddle) || (header->flags.B.frameType == Ifx_Oe_SyncProtocol_FrameType_dataEnd)) && (header->length > client->receive.messagePayloadBufferSize))
                    )
                {
                    /* Message buffer is locked for read, or buffer lenght too small. Send port closed ACK and discard message */
                    Ifx_Oe_SyncProtocol_raiseAck(protocol, header->flags.B.index, Ifx_Oe_SyncProtocol_Ack_portClosed);
                    protocol->status.portClosed++;
                    protocol->receive.frameHeaderByteIndex = 0;
                }
                else if (client->remotePort != header->sender)
                {
                    /* Message sender / receiver does not match. Send port closed ACK and discard message */
                    Ifx_Oe_SyncProtocol_raiseAck(protocol, header->flags.B.index, Ifx_Oe_SyncProtocol_Ack_portClosed);
                    protocol->status.portClosed++;
                    protocol->receive.frameHeaderByteIndex = 0;
                }
                else if (client->receive.messageValid)
                {
                    /* Message buffer is validbut not read. Send busy ACK and discard message */
                    Ifx_Oe_SyncProtocol_raiseAck(protocol, header->flags.B.index, Ifx_Oe_SyncProtocol_Ack_busy);
                    protocol->status.portBusy++;
                    protocol->receive.frameHeaderByteIndex = 0;
                }
                else
                {
                    /* Prepare for payload read */

                    /* FIXME add check for frame index mismatch (missing frame, wrong frame order. The packed checksum is not handling this. There is no message checksum) */
                    switch (header->flags.B.frameType)
                    {
                    case Ifx_Oe_SyncProtocol_FrameType_data:
                    case Ifx_Oe_SyncProtocol_FrameType_dataStart:
                        protocol->receive.payloadHeader = *header;

                        if (header->length > 0)
                        {
                            Ifx_Oe_SyncProtocol_raiseAck(protocol, header->flags.B.index, Ifx_Oe_SyncProtocol_Ack_headerOk);
                            client->receive.messageValid            = FALSE;
                            client->receive.messageByteIndex        = 0;

                            protocol->receive.framePayloadByteIndex = 0;
                            protocol->receive.state                 = Ifx_Oe_SyncProtocol_ReceiveState_waitingForPayload;
                        }
                        else
                        {
                            Ifx_Oe_SyncProtocol_raiseAck(protocol, header->flags.B.index, Ifx_Oe_SyncProtocol_Ack_headerOk);
                            protocol->receive.frameHeaderByteIndex = 0;
                        }

                        break;
                    case Ifx_Oe_SyncProtocol_FrameType_dataMiddle:
                    case Ifx_Oe_SyncProtocol_FrameType_dataEnd:
                        protocol->receive.payloadHeader = *header;

                        if (client->receive.messageHeader.length > client->receive.messagePayloadBufferSize)
                        { /* FIXME return dedicated ACK: Message to big for buffer FIXME Check could be done earlier when the message header is decoded */
                            Ifx_Oe_SyncProtocol_raiseAck(protocol, header->flags.B.index, Ifx_Oe_SyncProtocol_Ack_portClosed);
                            protocol->status.portBusy++;
                            protocol->receive.frameHeaderByteIndex = 0;
                        }
                        else if (header->length > 0)
                        {
                            Ifx_Oe_SyncProtocol_raiseAck(protocol, header->flags.B.index, Ifx_Oe_SyncProtocol_Ack_headerOk);
                            protocol->receive.framePayloadByteIndex = 0;
                            protocol->receive.state                 = Ifx_Oe_SyncProtocol_ReceiveState_waitingForPayload;
                        }
                        else
                        {
                            Ifx_Oe_SyncProtocol_raiseAck(protocol, header->flags.B.index, Ifx_Oe_SyncProtocol_Ack_headerOk);
                            protocol->receive.frameHeaderByteIndex = 0;
                        }

                        break;
                    case Ifx_Oe_SyncProtocol_FrameType_ack:

                        if (protocol->waitingForPayload)
                        {
                            /* An ACk have been received while a frame was in receive process, continue receiving the frame */
                            ASSERT(protocol->receive.framePayloadByteIndex == 0);
                            protocol->waitingForPayload = FALSE;
                            protocol->receive.state     = Ifx_Oe_SyncProtocol_ReceiveState_waitingForPayload;
                        }
                        else
                        {
                            protocol->receive.frameHeaderByteIndex = 0;
                        }

                        break;
                    }
                }

                Ifx_Oe_SyncProtocol_processAck(protocol, header);
            }
            else
            {
                /* Invalid header */

                if (protocol->synchronized)
                {
                    IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_readHeader [%1]: Invalid header received while synchronized : lastValidFrameIndex=%2").arg((uint64)protocol, 0, 16).arg(protocol->receive.lastValidFrameIndex));
                    protocol->status.invalidHeader++;
                    Ifx_Oe_SyncProtocol_raiseAck(protocol, Ifx_Oe_SyncProtocol_getNextIndex(protocol->receive.lastValidFrameIndex), Ifx_Oe_SyncProtocol_Ack_headerError);
                    protocol->synchronized = FALSE;
                }

                /* search for a new start byte in the header */
                {
                    uint8* src = (uint8*)&header;
                    uint8* dst;
                    uint8  index;
                    /* Discard the current start byte */
                    dst                                    = src;
                    index                                  = 1;
                    protocol->receive.frameHeaderByteIndex = 0;

                    while (index < IFX_OE_SYNCPROTOCOL_FRAME_HEADER_SIZE)
                    {
                        if (src[index] == IFX_OE_SYNCPROTOCOL_HEADER_START_BYTE)
                        {
                            protocol->receive.frameHeaderByteIndex++;
                            index++;

                            /* Copy header */
                            while (index < IFX_OE_SYNCPROTOCOL_FRAME_HEADER_SIZE)
                            {
                                dst[protocol->receive.frameHeaderByteIndex++] = src[index++];
                            }
                        }
                        else
                        {
                            index++;
                        }
                    }
                }
            }
        }
    }
}


static void Ifx_Oe_SyncProtocol_processIncomming(Ifx_Oe_SyncProtocol* protocol)
{
    /* Look for header */
    if (protocol->receive.state == Ifx_Oe_SyncProtocol_ReceiveState_waitingForHeader)
    {
        Ifx_Oe_SyncProtocol_readHeader(protocol);
    }
    else if (protocol->receive.deadline <= IFX_OE_SYNCPROTOCOL_CURRENT_TIME)
    {
        protocol->status.receiveTimeout++;
        protocol->receive.frameHeaderByteIndex = 0;
        protocol->waitingForPayload            = FALSE;
        protocol->receive.state                = Ifx_Oe_SyncProtocol_ReceiveState_waitingForHeader;
        IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processIncomming [%1]: Receive timeout").arg((uint64)protocol, 0, 16));
    }
    /* Check if the next data is ack header or payload */
    else if (protocol->receive.state == Ifx_Oe_SyncProtocol_ReceiveState_waitingForPayload)
    {
        sint32 readCount;
        readCount = 1;
        uint8 data = 0;
        readCount = readCount - Ifx_Oe_SyncProtocol_DPipeRead(protocol->streamStdif, &data, readCount);

        if (readCount == 1)
        {
            if (data == IFX_OE_SYNCPROTOCOL_HEADER_START_BYTE)
            {
                IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processIncomming [%1]: Header start byte received").arg((uint64)protocol, 0, 16));
                protocol->receive.header.startByte     = IFX_OE_SYNCPROTOCOL_HEADER_START_BYTE;
                protocol->receive.frameHeaderByteIndex = 1;
                protocol->receive.state                = Ifx_Oe_SyncProtocol_ReceiveState_waitingForHeader;
                protocol->waitingForPayload            = TRUE;
            }
            else if (data == IFX_OE_SYNCPROTOCOL_PAYLOAD_START_BYTE)
            {
                IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processIncomming [%1]: Payload start byte received").arg((uint64)protocol, 0, 16));
                protocol->receive.state = Ifx_Oe_SyncProtocol_ReceiveState_readingPayload;
            }
            else
            {
                protocol->status.invalidStartByte++;
                protocol->receive.frameHeaderByteIndex = 0;
                protocol->waitingForPayload            = FALSE;
                protocol->receive.state                = Ifx_Oe_SyncProtocol_ReceiveState_waitingForHeader;
            }
        }
    }
    /* Read payload */
    else if (protocol->receive.state == Ifx_Oe_SyncProtocol_ReceiveState_readingPayload)
    {
        sint32                           readCount;
        Ifx_Oe_SyncProtocol_FrameHeader* header = &protocol->receive.payloadHeader;
        Ifx_Oe_SyncProtocol_Client*      client = protocol->clients[header->receiver];
        ASSERT(client != NULL); /* Expected to be not null as it is checked while processing the header */
        boolean messageHeaderPresent            = (header->flags.B.frameType == Ifx_Oe_SyncProtocol_FrameType_data) || (header->flags.B.frameType == Ifx_Oe_SyncProtocol_FrameType_dataStart);

        ASSERT(header->length > 0);

        /* Read message header */
        readCount = IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE - client->receive.messageByteIndex;

        if (messageHeaderPresent && (readCount > 0))
        {
            readCount                                = readCount - Ifx_Oe_SyncProtocol_DPipeRead(protocol->streamStdif, (void*)&((uint8*)&client->receive.messageHeader)[client->receive.messageByteIndex], readCount);
            protocol->receive.framePayloadByteIndex += (uint8)readCount;
            client->receive.messageByteIndex        += readCount;
        }

        if (!messageHeaderPresent || (client->receive.messageByteIndex >= IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE))
        {
            /* Read message payload */
            readCount = header->length - protocol->receive.framePayloadByteIndex;

            if (readCount > 0)
            {
                readCount                                = readCount - Ifx_Oe_SyncProtocol_DPipeRead(protocol->streamStdif, (void*)&client->receive.messagePayload[client->receive.messageByteIndex - IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE], readCount);
                protocol->receive.framePayloadByteIndex += (uint8)readCount;
                client->receive.messageByteIndex        += readCount;
            }
        }

        if (protocol->receive.framePayloadByteIndex == header->length)
        {
            uint8 checksum;

            if (client->receive.messageByteIndex - header->length == 0)
            {
                checksum = Ifx_Oe_SyncProtocol_calculateFramePayloadChecksum(
                    header,
                    &client->receive.messageHeader,
                    &client->receive.messagePayload[0]);
            }
            else
            {
                checksum = Ifx_Oe_SyncProtocol_calculateFramePayloadChecksum(
                    header,
                    NULL,
                    &client->receive.messagePayload[client->receive.messageByteIndex - IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE /* FIXME - IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE => bug? */ - header->length]);
            }

            if (header->checksumPayload == checksum)
            {
                IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processIncomming [%1]: Payload received").arg((uint64)protocol, 0, 16));
                Ifx_Oe_SyncProtocol_raiseAck(protocol, header->flags.B.index, Ifx_Oe_SyncProtocol_Ack_payloadOk);
                protocol->receive.frameHeaderByteIndex = 0;
                protocol->waitingForPayload            = FALSE;
                protocol->receive.state                = Ifx_Oe_SyncProtocol_ReceiveState_waitingForHeader; /* FIXME What about multi frame message ? */

                if (client->receive.messageByteIndex == client->receive.messageHeader.length)
                {
                    IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processIncomming [%1]: Message received, ID=0x%2").arg((uint64)protocol, 0, 16).arg(client->receive.messageHeader.id, 0, 16));
                    client->receive.messageValid = TRUE;
                }
            }
            else
            {
                IFX_OE_SYNCPROTOCOL_DEBUG(QString("Ifx_Oe_SyncProtocol_processIncomming [%1]: Payload received (checksum error)").arg((uint64)protocol, 0, 16));
                Ifx_Oe_SyncProtocol_raiseAck(protocol, header->flags.B.index, Ifx_Oe_SyncProtocol_Ack_payloadError);
                client->receive.messageByteIndex       -= protocol->receive.framePayloadByteIndex;
                protocol->receive.framePayloadByteIndex = 0;
                protocol->receive.state                 = Ifx_Oe_SyncProtocol_ReceiveState_waitingForPayload;
                protocol->status.payloadError++;
            }
        }
    }
}


boolean Ifx_Oe_SyncProtocol_printInfo(Ifx_Oe_SyncProtocol* protocol, char* buffer, size_t maxBufferSize)
{
#if IFX_OE_SYNCPROTOCOL_USE_PRIVATE_HEAP == 0
    IFX_OE_SYNCPROTOCOL_UNUSED(protocol);

    if (maxBufferSize > 0)
    {
        buffer[0] = 0;
        return TRUE;
    }
    else
    {
        return FALSE;
    }

#else
    int cx;
    cx = snprintf(
        buffer,
        maxBufferSize,
        "Ifx_Oe_SyncProtocol:" IFX_OE_ENDL
        " - Message memory pool: size=%d, free=%d, max used=%d" IFX_OE_ENDL,
        (int)Ifx_Oe_Malloc_size(protocol->memoryPool),
        (int)protocol->memoryPool->memFree,
        (int)protocol->memoryPool->memMaxUsed);
    return cx >= 0 && cx < maxBufferSize;
#endif
}
