/**
 * \file ifx_oe_osci.c
 * \brief  Osci
 *
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
//----------------------------------------------------------------------------------------
#include "ifx_oe_osci.h"
#if IFX_CFG_OE_OSCI_FFT_LENGTH != 0
#include "SysSe/Math/Ifx_FftF32.h"
#include "SysSe/Math/Ifx_WndF32.h"
#endif
#if IFX_CFG_OE_OSCI_HAVE_MATH != 0
#include "SysSe/Math/Ifx_LutLSincosF32.h"
#include "SysSe/Math/Ifx_LutAtan2F32.h"
#endif

#include "stdlib.h"
#include <string.h>
#include <stddef.h>

//----------------------------------------------------------------------------------------

#define IFX_OE_OSCI_PWR_DB(p) (20.0 * log10f(p))
static void Ifx_Oe_Osci_handleControlRequest(Ifx_Oe_Osci* osci);
void        Ifx_Oe_Osci_setSamplingIntervalPrivate(Ifx_Oe_Osci* osci, sint16 interval);

/** \brief Returns null-terminated string name of the requested type */
pchar Ifx_Oe_Osci_getDataTypeName(Ifx_Oe_Osci_DataType type)
{
    pchar result;

    switch (type)
    {
    case Ifx_Oe_Osci_DataType_Float32:
        result = "float32";
        break;
    case Ifx_Oe_Osci_DataType_SInt16:
        result = "sint16";
        break;
    case Ifx_Oe_Osci_DataType_SInt32:
        result = "sint32";
        break;
    case Ifx_Oe_Osci_DataType_FixPoint16:
        result = "FixPoint16";
        break;
    case Ifx_Oe_Osci_DataType_FixPoint32:
        result = "FixPoint32";
        break;
    case Ifx_Oe_Osci_DataType_SInt8:
        result = "sint8";
        break;
    case Ifx_Oe_Osci_DataType_UInt8:
        result = "uint8";
        break;
    case Ifx_Oe_Osci_DataType_boolean:
        result = "boolean";
        break;
    case Ifx_Oe_Osci_DataType_SInt64:
        result = "sint64";
        break;
    case Ifx_Oe_Osci_DataType_UInt64:
        result = "uint64";
        break;
    case Ifx_Oe_Osci_DataType_FctPtr_Float32:
        result = "Float32";
        break;
    case Ifx_Oe_Osci_DataType_FctPtr_SInt16:
        result = "SInt16";
        break;
    case Ifx_Oe_Osci_DataType_FctPtr_UInt16:
        result = "UInt16";
        break;
    case Ifx_Oe_Osci_DataType_FctPtr_SInt32:
        result = "SInt32";
        break;
    case Ifx_Oe_Osci_DataType_FctPtr_UInt32:
        result = "UInt32";
        break;
    case Ifx_Oe_Osci_DataType_FctPtr_FixPoint16:
        result = "FixPoint16";
        break;
    case Ifx_Oe_Osci_DataType_FctPtr_FixPoint32:
        result = "FixPoint32";
        break;
    case Ifx_Oe_Osci_DataType_FctPtr_SInt8:
        result = "SInt8";
        break;
    case Ifx_Oe_Osci_DataType_FctPtr_UInt8:
        result = "UInt8";
        break;
    case Ifx_Oe_Osci_DataType_FctPtr_boolean:
        result = "boolean";
        break;
    case Ifx_Oe_Osci_DataType_FctPtr_SInt64:
        result = "SInt64";
        break;
    case Ifx_Oe_Osci_DataType_FctPtr_UInt64:
        result = "UInt64";
        break;

    case Ifx_Oe_Osci_DataType_Align32Bit:
    default:
        result = "Unknown";
        break;
    }

    return result;
}


float32 Ifx_Oe_Osci_valueGet(Ifx_Oe_Osci_Channel* channel)
{
    if (channel->signal == NULL_PTR)
    {
        return 0.0;
    }

    return channel->signal->getFctPtr(channel->signal);
}


boolean Ifx_Oe_Osci_isEdgeDetected(Ifx_Oe_Osci* osci)
{
    boolean              edgeDetected = FALSE;
    Ifx_Oe_Osci_Trigger* triggerPtr   = &osci->trigger;
    Ifx_Oe_Osci_Channel* channel      = &osci->channels[triggerPtr->source];
    float32              value        = Ifx_Oe_Osci_valueGet(channel);

    switch (triggerPtr->edge)
    {
    case Ifx_Oe_Osci_TriggerEdge_rising:
        edgeDetected = (triggerPtr->previousValue < triggerPtr->level) && (value >= triggerPtr->level);
        break;
    case Ifx_Oe_Osci_TriggerEdge_falling:
        edgeDetected = (triggerPtr->previousValue > triggerPtr->level) && (value <= triggerPtr->level);
        break;
    case Ifx_Oe_Osci_TriggerEdge_align32Bit:
        break;
    }

    osci->trigger.previousValue = value;

    return edgeDetected;
}


/**
 * Write the current value of all channels at the current write index and increment it accordingly.
 * This is done with interrupt disabled.
 */
static void Ifx_Oe_Osci_getCurrentValues(Ifx_Oe_Osci* osci)
{
    uint32  i;
    boolean istate = Ifx_Oe_disableInterrupts();

    /* write new values */
    for (i = 0; i < IFX_CFG_OE_OSCI_MAX_NUM_OF_CHANNELS; i++)
    {
        Ifx_Oe_Osci_Channel* channel = &osci->channels[i];
        channel->values[osci->writeIndex] = Ifx_Oe_Osci_valueGet(channel);
    }

    Ifx_Oe_restoreInterrupts(istate);
}


static void Ifx_Oe_Osci_incrementReadWriteIndex(Ifx_Oe_Osci* osci)
{
    osci->writeIndex = (uint16)((osci->writeIndex + 1) % osci->dataLength);
    // ReadIndex is always the next value following WriteIndex, as we assume this is the oldest value
    osci->readIndex  = (uint16)((osci->writeIndex + 1) % osci->dataLength);
}


void Ifx_Oe_Osci_stepForced(Ifx_Oe_Osci* osci)
{
    Ifx_Oe_Osci_getCurrentValues(osci);
}


void Ifx_Oe_Osci_arm(Ifx_Oe_Osci* osci)
{
    Ifx_Oe_Osci_Trigger* triggerPtr = &osci->trigger;
    osci->writeIndex            = 0;
    osci->readIndex             = 0;

    osci->trigger.previousValue = Ifx_Oe_Osci_valueGet(&osci->channels[osci->trigger.source]);
    triggerPtr->state           = Ifx_Oe_Osci_TriggerState_armed;
    triggerPtr->arm             = FALSE;
    osci->dataTransfered        = FALSE;
    osci->stateChanged          = TRUE;
}


boolean Ifx_Oe_Osci_dataTransferDone(Ifx_Oe_Osci* osci)
{
    return (osci->remoteControlled && osci->dataTransfered) || !osci->remoteControlled;
}


static void Ifx_Oe_Osci_stepAutomatic(Ifx_Oe_Osci* osci)
{
    Ifx_Oe_Osci_Trigger* triggerPtr = &osci->trigger;

    if (triggerPtr->state == Ifx_Oe_Osci_TriggerState_armed)
    {
        triggerPtr->state  = Ifx_Oe_Osci_TriggerState_triggered;
        osci->stateChanged = TRUE;
    }

    switch (triggerPtr->state)
    {
    case Ifx_Oe_Osci_TriggerState_triggered:
        /* get current value for all channels */
        Ifx_Oe_Osci_getCurrentValues(osci);
        Ifx_Oe_Osci_incrementReadWriteIndex(osci);

        if (osci->writeIndex == 0)     //write index == 0 means we wrapped around -> buffer is full
        {
            triggerPtr->state  = Ifx_Oe_Osci_TriggerState_dataTransfer;
            osci->stateChanged = TRUE;
        }

        break;
    case Ifx_Oe_Osci_TriggerState_dataTransfer:

        if (Ifx_Oe_Osci_dataTransferDone(osci))
        {
            if (triggerPtr->single)
            {
                triggerPtr->state  = Ifx_Oe_Osci_TriggerState_stopped;
                osci->stateChanged = TRUE;
            }
            else
            {
                Ifx_Oe_Osci_arm(osci);
            }
        }

        break;
    case Ifx_Oe_Osci_TriggerState_stopped:

        if (triggerPtr->arm)
        {
            Ifx_Oe_Osci_arm(osci);
        }
        else
        {
            /* do nothing (wait for re- arm) */
        }

        break;
    case Ifx_Oe_Osci_TriggerState_align32Bit:
    default:
        break;
    }
}


static void Ifx_Oe_Osci_stepNormal(Ifx_Oe_Osci* osci)
{
    Ifx_Oe_Osci_Trigger* triggerPtr = &osci->trigger;

    switch (triggerPtr->state)
    {
    case Ifx_Oe_Osci_TriggerState_armed:

        /* check if we triggered */
        if (Ifx_Oe_Osci_isEdgeDetected(osci) == TRUE)
        {
            triggerPtr->state  = Ifx_Oe_Osci_TriggerState_triggered;
            osci->stateChanged = TRUE;
            Ifx_Oe_Osci_getCurrentValues(osci);
            Ifx_Oe_Osci_incrementReadWriteIndex(osci);
        }

        break;

    case Ifx_Oe_Osci_TriggerState_triggered:
        Ifx_Oe_Osci_getCurrentValues(osci);
        Ifx_Oe_Osci_incrementReadWriteIndex(osci);

        if (osci->writeIndex == 0) //write index == 0 means we wrapped around -> buffer is full
        {
            triggerPtr->state  = Ifx_Oe_Osci_TriggerState_dataTransfer;
            osci->stateChanged = TRUE;
        }

        break;

    case Ifx_Oe_Osci_TriggerState_dataTransfer:

        if (Ifx_Oe_Osci_dataTransferDone(osci))
        {
            if (triggerPtr->single)
            {
                triggerPtr->state  = Ifx_Oe_Osci_TriggerState_stopped;
                osci->stateChanged = TRUE;
            }
            else
            {
                Ifx_Oe_Osci_arm(osci);
            }
        }

        break;
    case Ifx_Oe_Osci_TriggerState_stopped:

        if (triggerPtr->arm)
        {
            Ifx_Oe_Osci_arm(osci);
        }
        else
        {
            /* do nothing (wait for re- arm) */
        }

        break;

    default:
        break;
    }
}


static void Ifx_Oe_Osci_stepInverted(Ifx_Oe_Osci* osci)
{
    Ifx_Oe_Osci_Trigger* triggerPtr = &osci->trigger;

    if (triggerPtr->state == Ifx_Oe_Osci_TriggerState_triggered)
    {
        triggerPtr->state  = Ifx_Oe_Osci_TriggerState_stopped;
        osci->stateChanged = TRUE;
    }

    switch (triggerPtr->state)
    {
    case Ifx_Oe_Osci_TriggerState_armed:
        /* get current value for all channels */
        Ifx_Oe_Osci_getCurrentValues(osci);
        Ifx_Oe_Osci_incrementReadWriteIndex(osci);

        /* check if we triggered */
        if (Ifx_Oe_Osci_isEdgeDetected(osci) == TRUE)
        {
            triggerPtr->state  = Ifx_Oe_Osci_TriggerState_dataTransfer;
            osci->stateChanged = TRUE;
        }

        break;
    case Ifx_Oe_Osci_TriggerState_dataTransfer:

        if (Ifx_Oe_Osci_dataTransferDone(osci))
        {
            if (triggerPtr->single)
            {
                triggerPtr->state  = Ifx_Oe_Osci_TriggerState_stopped;
                osci->stateChanged = TRUE;
            }
            else
            {
                Ifx_Oe_Osci_arm(osci);
            }
        }

        break;
    case Ifx_Oe_Osci_TriggerState_stopped:

        if (triggerPtr->arm)
        {
            Ifx_Oe_Osci_arm(osci);
        }
        else
        {
            /* do nothing (wait for re- arm) */
        }

        break;    default:
        break;
    }
}


/**
 * \brief Step function, which shall be called every sampling period
 * The period was previously set by Ifx_Oe_Osci_init() function.
 *
 * \param osci Pointer to the oscilloscope object
 */
void Ifx_Oe_Osci_step(Ifx_Oe_Osci* osci)
{
    Ifx_Oe_Osci_handleControlRequest(osci);

    //exit if disabled
    if (osci->enabled == FALSE)
    {
        return;
    }

    //exit if sampling interval not reached
    osci->samplingIntervalTmp--;

    if (osci->samplingIntervalTmp != 0)
    {
        return;
    }
    else
    {
        osci->samplingIntervalTmp = osci->samplingInterval;
    }

    Ifx_Oe_Osci_Trigger* triggerPtr = &osci->trigger;

    switch (triggerPtr->mode)
    {
    case Ifx_Oe_Osci_TriggerMode_automatic:
        Ifx_Oe_Osci_stepAutomatic(osci);
        break;
    case Ifx_Oe_Osci_TriggerMode_normal:
        Ifx_Oe_Osci_stepNormal(osci);
        break;
    case Ifx_Oe_Osci_TriggerMode_inverted:
        Ifx_Oe_Osci_stepInverted(osci);
        break;

    case Ifx_Oe_Osci_TriggerMode_align32Bit:
        break;
    }
}


boolean Ifx_Oe_Osci_associateSignalToChannel(Ifx_Oe_Osci* osci, Ifx_Oe_Osci_SignalId signalId, Ifx_Oe_Osci_ChannelId channelId)
{
    if (channelId < IFX_CFG_OE_OSCI_MAX_NUM_OF_CHANNELS)
    {
        if (signalId == IFX_OE_OSCI_NO_SIGNAL)
        {
            osci->channels[channelId].signal = NULL_PTR;
            return TRUE;
        }
        else if (osci->signalList[signalId].id == IFX_OE_OSCI_NO_SIGNAL)
        {
            return FALSE;
        }
        else if (signalId < IFX_CFG_OE_OSCI_MAX_NUM_OF_SIGNALS)
        {
            osci->channels[channelId].signal = &osci->signalList[signalId];
            return TRUE;
        }
    }

    return FALSE;
}


Ifx_Oe_Osci_SignalId Ifx_Oe_Osci_getChannelSignal(Ifx_Oe_Osci* osci, Ifx_Oe_Osci_ChannelId channelId)
{
    if (channelId < IFX_CFG_OE_OSCI_MAX_NUM_OF_CHANNELS)
    {
        if (osci->channels[channelId].signal != NULL)
        {
            return osci->channels[channelId].signal->id;
        }
        else
        {
            return IFX_OE_OSCI_NO_SIGNAL;
        }
    }

    return IFX_OE_OSCI_NO_SIGNAL;
}


float32* Ifx_Oe_Osci_getChannelDataPointer(Ifx_Oe_Osci* osci, Ifx_Oe_Osci_ChannelId channelId)
{
    if (channelId < IFX_CFG_OE_OSCI_MAX_NUM_OF_CHANNELS)
    {
        if (osci->channels[channelId].signal != NULL)
        {
            return osci->channels[channelId].values;
        }
        else
        {
            return NULL;
        }
    }

    return NULL;
}


Ifx_Oe_Osci_SignalId Ifx_Oe_Osci_addSignal(Ifx_Oe_Osci* osci, pchar name, Ifx_Oe_Osci_DataType type, const void* source, sint16 qFormatShift)
{
    Ifx_Oe_Osci_SignalId retVal = IFX_OE_OSCI_NO_SIGNAL;

    if (osci->usedSignals < IFX_CFG_OE_OSCI_MAX_NUM_OF_SIGNALS)
    {
        /* Add the signal config */
        Ifx_Oe_Osci_Signal* signalPtr = &osci->signalList[osci->usedSignals];
        signalPtr->id                                               = osci->usedSignals;
        signalPtr->type                                             = type;
        signalPtr->getFctPtr                                        = Ifx_Oe_Osci_GetFctPtrArray[signalPtr->type];
        signalPtr->source                                           = source;
        signalPtr->qFormatShift                                     = qFormatShift;
        strncpy(&signalPtr->name[0], &name[0], IFX_CFG_OE_OSCI_SIGNAL_NAME_MAX_LENGTH);
        signalPtr->name[IFX_CFG_OE_OSCI_SIGNAL_NAME_MAX_LENGTH - 1] = 0;

        if (osci->autoAddChannels == TRUE)
        {
            for (Ifx_Oe_Osci_ChannelId i = 0; i < IFX_CFG_OE_OSCI_MAX_NUM_OF_CHANNELS; i++)
            {
                if (osci->channels[i].signal == NULL_PTR)
                {
                    Ifx_Oe_Osci_associateSignalToChannel(osci, signalPtr->id, i);
                    break;
                }
            }
        }

        osci->usedSignals++;
        retVal = signalPtr->id;
    }
    else
    {
    }

    return retVal;
}


Ifx_Oe_Osci_SignalId Ifx_Oe_Osci_getSignalIdFromName(Ifx_Oe_Osci* osci, pchar name)
{
    Ifx_Oe_Osci_SignalId i;

    for (i = 0; i < osci->maxNumOfSignals; i++)
    {
        Ifx_Oe_Osci_Signal* signalPtr = &osci->signalList[i];

        if (strcmp(signalPtr->name, name) == 0)
        {
            return signalPtr->id;
        }
    }

    return IFX_OE_OSCI_NO_SIGNAL;
}


/**
 * \brief Initialize an oscilloscope object.
 * \param osci Pointer to the oscilloscope object
 * \param config Oscilloscope configuration
 */
boolean Ifx_Oe_Osci_init(Ifx_Oe_Osci* osci, Ifx_Oe_Osci_Config* config)
{
    boolean result;
    osci->oneEyeOsci.marker = 0;
    IFX_OE_ASSERT(sizeof(Ifx_Oe_Osci_Trigger) == IFX_OE_OSCI_TRIGGER_STRUCT_SIZE);
    IFX_OE_ASSERT(sizeof(Ifx_Oe_Osci_ControlInterface) == IFX_OE_OSCI_CONTROLINTERFACE_STRUCT_SIZE);
    IFX_OE_ASSERT(sizeof(Ifx_Oe_Osci_OneEye) == IFX_OE_OSCI_ONEEYE_STRUCT_SIZE);
    IFX_OE_ASSERT(sizeof(Ifx_Oe_Osci_Header) == IFX_OE_OSCI_HEADER_STRUCT_SIZE);
    IFX_OE_ASSERT(offsetof(Ifx_Oe_Osci, checkMark) == IFX_OE_OSCI_OSCI_STRUCT_OFFSET_OF_CHECKMARK);

    result                         = TRUE;
    osci->oneEyeOsci.Version.major = IFX_OE_OSCI_VERSION_MAJOR;
    osci->oneEyeOsci.Version.minor = IFX_OE_OSCI_VERSION_MINOR;
    osci->oneEyeOsci.Version.patch = IFX_OE_OSCI_VERSION_PARCH;
    osci->header.channelListAddr   = (uint32)osci->channels;
    osci->header.signalListAddr    = (uint32)osci->signalList;
    osci->header.valuesAddr        = (uint32)osci->values;

    osci->dataLength               = IFX_CFG_OE_OSCI_NUM_OF_SAMPLES & 0xFFFE; /* Ensure even size */
    osci->samplePeriod             = config->samplePeriod;
    osci->autoAddChannels          = config->autoAddChannels;
    osci->maxNumOfChannels         = IFX_CFG_OE_OSCI_MAX_NUM_OF_CHANNELS;
    osci->maxNumOfSignals          = IFX_CFG_OE_OSCI_MAX_NUM_OF_SIGNALS;
    osci->maxNumOfSamples          = IFX_CFG_OE_OSCI_NUM_OF_SAMPLES;
    osci->remoteControlled         = FALSE;
    osci->dataTransfered           = FALSE;

    Ifx_Oe_Osci_clearControldata(&osci->controlInterface);

    /* Trigger initialisation */
    Ifx_Oe_Osci_Trigger* triggerPtr = &osci->trigger;
    triggerPtr->mode            = Ifx_Oe_Osci_TriggerMode_automatic;
    triggerPtr->state           = Ifx_Oe_Osci_TriggerState_stopped;
    triggerPtr->edge            = Ifx_Oe_Osci_TriggerEdge_rising;
    triggerPtr->level           = 0;
    osci->trigger.previousValue = 0.0;
    triggerPtr->source          = 0;
    triggerPtr->single          = FALSE;
    triggerPtr->arm             = FALSE;
    triggerPtr->position        = 0;
    triggerPtr->reserved_1      = 0;
    triggerPtr->reserved_2      = 0;

    osci->enabled               = FALSE;

    Ifx_Oe_Osci_setSamplingIntervalPrivate(osci, 1);

    osci->readIndex    = 0;
    osci->writeIndex   = 0;
    osci->stateChanged = FALSE;

#if IFX_CFG_OE_OSCI_FFT_LENGTH != 0
    //Initialize FFT
    osci->fft.span   = 0;
    osci->fft.source = 0;
    osci->fft.length = IFX_CFG_OE_OSCI_FFT_LENGTH & 0xFFFE; /* Ensure even size */

    if ((osci->fft.length > 0) && (osci->fft.length <= osci->dataLength))
    {
        osci->fft.padLength = osci->fft.length - osci->dataLength;
    }
    else
    {
        osci->fft.padLength = 0;
    }

    osci->fft.enabled = FALSE;
#endif

    osci->usedSignals = 0;

    for (int i = 0; i < IFX_CFG_OE_OSCI_MAX_NUM_OF_CHANNELS; i++)
    {
        osci->channels[i].signal = NULL_PTR;
        osci->channels[i].values = &osci->values[i][0];

        for (int j = 0; j < osci->dataLength; j++)
        {
            osci->values[i][j] = 0.0;
        }
    }

    for (int i = 0; i < IFX_CFG_OE_OSCI_MAX_NUM_OF_SIGNALS; i++)
    {
        osci->signalList[i].id     = IFX_OE_OSCI_NO_SIGNAL;
        osci->signalList[i].name   = osci->signalNames[i];
        memset(&osci->signalNames[i][0], 0, IFX_CFG_OE_OSCI_SIGNAL_NAME_MAX_LENGTH);
        osci->signalList[i].source = NULL_PTR;
        osci->signalList[i].type   = Ifx_Oe_Osci_DataType_Unknown;
    }

    uint32 i;
    osci->checkMark = 0;

    for (i = offsetof(Ifx_Oe_Osci, header); i < offsetof(Ifx_Oe_Osci, checkMark); i++)
    {
        osci->checkMark += ((uint8*)osci)[i];
    }

    /* must be done only after complete initialization */
    strncpy((char*)&osci->oneEyeOsci.marker, IFX_OE_OSCI_MARKER, sizeof(osci->oneEyeOsci.marker));

    return result;
}


boolean Ifx_Oe_Osci_setDepthPrivate(Ifx_Oe_Osci* osci, uint32 depth)
{
    if (depth > IFX_CFG_OE_OSCI_NUM_OF_SAMPLES)
    {
        return FALSE;
    }
    else
    {
        osci->dataLength = depth & 0xFFFFFFFE; /* Ensure even size */

#if IFX_CFG_OE_OSCI_FFT_LENGTH != 0

        if ((osci->fft.length > 0) && (osci->fft.length <= osci->dataLength))
        {
            osci->fft.padLength = osci->fft.length - osci->dataLength;
        }
        else
        {
            osci->fft.padLength = 0;
        }

#endif

        return TRUE;
    }
}


void Ifx_Oe_Osci_setSamplingIntervalPrivate(Ifx_Oe_Osci* osci, sint16 interval)
{
    osci->samplingInterval    = IFX_OE_SATURATE(interval, 1, 256);
    osci->samplingIntervalTmp = IFX_OE_SATURATE(interval, 1, 256);
}


void Ifx_Oe_Osci_setSamplingPeriod(Ifx_Oe_Osci* osci, float32 samplePeriod)
{
    osci->samplePeriod = samplePeriod;
}


float32 Ifx_Oe_Osci_getSamplingPeriod(Ifx_Oe_Osci* osci)
{
    return osci->samplePeriod;
}


void Ifx_Oe_Osci_initConfig(Ifx_Oe_Osci_Config* config)
{
    config->samplePeriod = 0;
    config->triggerMode  = Ifx_Oe_Osci_TriggerMode_automatic;
}


/** \brief Get the next data since the last reading
 * \param osci Pointer to the Ifx_Oe_Osci object
 * \param data Pointer to buffer which shall fits (sizeof(float32) * osci->channelCount) */
boolean Ifx_Oe_Osci_getNextData(Ifx_Oe_Osci* osci, float32* data)
{
    boolean istate = Ifx_Oe_disableInterrupts();

    /* reading not allowed if writing over values is possible */

    boolean canRead = TRUE;

    if (osci->enabled != FALSE)
    {
        canRead = FALSE;
    }

    if (osci->readIndex == osci->writeIndex)
    {
        canRead = FALSE;
    }

    /* can't read if readIndex has reached writeIndex */
    if (canRead == TRUE)
    {
        int i;

        for (i = 0; i < IFX_CFG_OE_OSCI_MAX_NUM_OF_CHANNELS; i++)
        {
            data[i] = osci->values[i][osci->readIndex];
        }

        osci->readIndex++;
        osci->readIndex = osci->readIndex % osci->dataLength;
    }
    else
    {
        canRead = FALSE;
    }

    Ifx_Oe_restoreInterrupts(istate);

    return canRead;
}


#if IFX_CFG_OE_OSCI_HAVE_MATH != 0
void Ifx_Oe_Osci_doSignalOperation(Ifx_Oe_Osci* osci, Ifx_Oe_Osci_Channel* result, Ifx_Oe_Osci_Channel* a, Ifx_Oe_Osci_Operation op, Ifx_Oe_Osci_SignalType type, float32 freq, float32 ampl, float32 offset, float32 phase)
{
    sint16 i;

    freq = freq * osci->samplePeriod;

    for (i = 0; i < osci->dataLength; i++)
    {
        float32 value;

        if (type == Ifx_Oe_Osci_SignalType_square)
        {
            value = 2.0 * IFX_PI * freq * i;
            value = (value < IFX_PI) ? 1.0f : -1.0f;
        }
        else
        {
            //value = sin((2.0 * IFX_PI * freq * i) + (phase / 180 * IFX_PI));
            value = (2.0 * IFX_LUT_ANGLE_PI * freq * i) + (phase / 180 * IFX_LUT_ANGLE_PI);
            value = Ifx_LutLSincosF32_cos(__roundf(value));
        }

        value = (ampl * value) + offset;

        switch (op)
        {
        case Ifx_Oe_Osci_Operation_add:
            result->values[i] = a->values[i] + value;
            break;
        case Ifx_Oe_Osci_Operation_sub:
            result->values[i] = a->values[i] - value;
            break;
        case Ifx_Oe_Osci_Operation_mul:
            result->values[i] = a->values[i] * value;
            break;
        case Ifx_Oe_Osci_Operation_div:
            result->values[i] = a->values[i] / value;
            break;
        case Ifx_Oe_Osci_Operation_clr:
            result->values[i] = 0;
            break;
        case Ifx_Oe_Osci_Operation_set:
        default:
            result->values[i] = value;
            break;
        }
    }
}


void Ifx_Oe_Osci_doChannelOperation(Ifx_Oe_Osci* osci, Ifx_Oe_Osci_Channel* result, Ifx_Oe_Osci_Channel* a, Ifx_Oe_Osci_Operation op, Ifx_Oe_Osci_Channel* b)
{
    sint16 i;

    switch (op)
    {
    case Ifx_Oe_Osci_Operation_atan2:

        for (i = 0; i < osci->dataLength; i++)
        {
            result->values[i] = (float32)Ifx_LutAtan2F32_fxpAngle(a->values[i], b->values[i]);
        }

        break;
    case Ifx_Oe_Osci_Operation_add:

        for (i = 0; i < osci->dataLength; i++)
        {
            result->values[i] = a->values[i] + b->values[i];
        }

        break;
    case Ifx_Oe_Osci_Operation_sub:

        for (i = 0; i < osci->dataLength; i++)
        {
            result->values[i] = a->values[i] - b->values[i];
        }

        break;
    case Ifx_Oe_Osci_Operation_mul:

        for (i = 0; i < osci->dataLength; i++)
        {
            result->values[i] = a->values[i] * b->values[i];
        }

        break;
    case Ifx_Oe_Osci_Operation_div:

        for (i = 0; i < osci->dataLength; i++)
        {
            result->values[i] = a->values[i] / b->values[i];
        }

        break;
    case Ifx_Oe_Osci_Operation_clr:

        for (i = 0; i < osci->dataLength; i++)
        {
            result->values[i] = 0;
        }

        break;
    case Ifx_Oe_Osci_Operation_set:

        for (i = 0; i < osci->dataLength; i++)
        {
            result->values[i] = a->values[i];
        }

        break;
    default:
        break;
    }
}


#endif

#if IFX_CFG_OE_OSCI_FFT_LENGTH != 0
void Ifx_Oe_Osci_analyze(Ifx_Oe_Osci* osci)
{
    if (osci->fft.length == 0)
    {
        return;
    }

    if (osci->fft.enabled)
    {
        osci->enabled = FALSE; //prevent modification of values while the analysis is running

        Ifx_Oe_Osci_AnalyzeResult result;
        sint16                    i;
        sint16                    lowerIdx = 0, upperIdx = 0, peakIdx = 0;

        Ifx_Oe_Osci_Channel* channel = &osci->channels[osci->fft.source];

        /* Compensate DC-offset */
        result.dcOffset = VecAvg_f32(channel->values, osci->dataLength);
        VecOfs_f32(channel->values, result.dcOffset, osci->dataLength);

        /* Copy data buffer */
        /* Initializing buffer with osci->dataLength data */
        for (i = 0; i < osci->dataLength; i++)   /* set with values from oscilloscope */
        {
            IFX_Cf32_set(&osci->fft.in[i], channel->values[i], 0);
        }

        if (osci->fft.padLength > 0)
        {
            /* Zero padding */
            /* Zero-padding last osci->fft.padLength data */
            for ( ; i < osci->fft.length; i++)  /* zero padding */
            {
                IFX_Cf32_reset(&osci->fft.in[i]);
            }
        }

        /* Windowing */
        /* Applying data window osci->dataLength */
        Ifx_WndF32_apply(osci->fft.in, Ifx_g_WndF32_blackmanHarrisTable, osci->dataLength);

        /* Fourier transform */
        /* Executing FFT-2 osci->fft.length */
        Ifx_FftF32_radix2(osci->fft.out.X, osci->fft.in, osci->fft.length);

        CplxVecPwr_f32(osci->fft.out.X, osci->fft.length / 2);

        /* Total power at half spectrum */
        //VecGain_f32(osci->fft.out.pwr, 2.0,  osci->fft.length/2);
        result.pTot = VecSum_f32(osci->fft.out.pwr, osci->fft.length / 2);

        /* Peak power and frequency */
        result.pPeak = VecMaxIdx_f32(osci->fft.out.pwr, osci->fft.length / 2, &lowerIdx, &upperIdx);
        peakIdx      = (upperIdx + lowerIdx) / 2;
        result.fPeak = peakIdx * 1.0 / (osci->fft.length * osci->samplePeriod);

        /* Signal power */
        result.pSig = VecSum_f32(&osci->fft.out.pwr[peakIdx - osci->fft.span], 2 * (sint16)osci->fft.span + 1);

        /* Noise and Distortion */
        result.pnd = result.pTot - result.pSig;

        VecPwrdB_f32(osci->fft.out.pwr, osci->fft.length / 2);

        result.signalPeakDb            = IFX_OE_OSCI_PWR_DB(result.pPeak);
        result.signalNoiseDistortionDb = IFX_OE_OSCI_PWR_DB(result.pTot);
        result.noiseDistortionDb       = IFX_OE_OSCI_PWR_DB(result.pnd);
        result.sinad                   = IFX_OE_OSCI_PWR_DB(result.pTot / result.pnd);
        result.enob                    = (result.sinad - 1.76) / 6.02;

        osci->fft.result               = result;
        osci->fft.enabled              = FALSE;
        osci->enabled                  = TRUE;
    }
}


#endif

void Ifx_Oe_Osci_clearControldata(Ifx_Oe_Osci_ControlInterface* actions)
{
    actions->flags1           = 0;
    actions->flags2           = 0;
    actions->bufferDepth      = 0;
    actions->triggerPosition  = 0;
    actions->triggerLevel     = 0;
    actions->samplingInterval = 0;
    actions->triggerSource    = 0;
    actions->reserved_2       = 0;
    actions->reserved_3       = 0;
    actions->reserved_4       = 0;
}


void Ifx_Oe_Osci_handleControlRequest(Ifx_Oe_Osci* osci)
{
    if (osci->controlInterface.updateRequest == 1)
    {
        /* Mark the data are being read */
        osci->controlInterface.updateRequest = 2;

        if (osci->controlInterface.remoteControlled != 0)
        {
            osci->remoteControlled = osci->controlInterface.remoteControlled & 0x1;
        }

        if (osci->controlInterface.enable != 0)
        {
            boolean enabled = osci->controlInterface.enable & 0x1;

            if (osci->enabled != enabled)
            {
                osci->enabled       = enabled;
                osci->trigger.state = Ifx_Oe_Osci_TriggerState_stopped;

                if (osci->enabled)
                {
                    osci->trigger.arm = TRUE;
                }
            }
        }

        if (osci->controlInterface.single != 0)
        {
            osci->trigger.single = osci->controlInterface.single & 0x1;
        }

        if (osci->controlInterface.armTrigger != 0)
        {
            if (osci->trigger.state == Ifx_Oe_Osci_TriggerState_stopped)
            {
                osci->trigger.arm = TRUE;
            }
        }

        if (osci->controlInterface.forceTrigger != 0)
        {
            if (osci->trigger.state == Ifx_Oe_Osci_TriggerState_armed)
            {
                osci->trigger.state = Ifx_Oe_Osci_TriggerState_triggered;
            }
        }

        if (osci->controlInterface.dataTransfered != 0)
        {
            if (osci->trigger.state == Ifx_Oe_Osci_TriggerState_dataTransfer)
            {
                osci->dataTransfered = TRUE;
            }
        }

        if (osci->controlInterface.triggerMode != 0)
        {
            Ifx_Oe_Osci_TriggerMode mode = osci->controlInterface.triggerMode & 0x3;

            if (osci->trigger.mode != mode)
            {
                osci->trigger.mode = mode;

                if (osci->trigger.state != Ifx_Oe_Osci_TriggerState_stopped)
                {
                    osci->trigger.state = Ifx_Oe_Osci_TriggerState_stopped;
                    osci->trigger.arm   = TRUE;
                }
            }
        }

        if (osci->controlInterface.triggerEdge != 0)
        {
            osci->trigger.edge = osci->controlInterface.triggerEdge & 0x1;
        }

        if (osci->controlInterface.setBufferDepth != 0)
        {
            uint32 bufferDepth = osci->controlInterface.bufferDepth & 0xFFFFFFFE;

            if (osci->dataLength != bufferDepth)
            {
                Ifx_Oe_Osci_setDepthPrivate(osci, bufferDepth);

                if (osci->trigger.state != Ifx_Oe_Osci_TriggerState_stopped)
                {
                    osci->trigger.state = Ifx_Oe_Osci_TriggerState_stopped;
                    osci->trigger.arm   = TRUE;
                }
            }

            osci->stateChanged = bufferDepth != osci->controlInterface.setBufferDepth;
        }

        if (osci->controlInterface.setSamplingInterval != 0)
        {
            uint16 samplingInterval = IFX_OE_SATURATE(osci->controlInterface.samplingInterval, 1, 256);

            if (osci->samplingInterval != samplingInterval)
            {
                Ifx_Oe_Osci_setSamplingIntervalPrivate(osci, samplingInterval);

                if (osci->trigger.state != Ifx_Oe_Osci_TriggerState_stopped)
                {
                    osci->trigger.state = Ifx_Oe_Osci_TriggerState_stopped;
                    osci->trigger.arm   = TRUE;
                }
            }

            osci->stateChanged = samplingInterval != osci->controlInterface.samplingInterval;
        }

        if (osci->controlInterface.setTriggerLevel != 0)
        {
            osci->trigger.level = osci->controlInterface.triggerLevel;
        }

        if (osci->controlInterface.setTriggerSource != 0)
        {
            osci->trigger.source        = IFX_OE_SATURATE(osci->controlInterface.triggerSource, 0, IFX_CFG_OE_OSCI_MAX_NUM_OF_CHANNELS - 1);
            osci->trigger.previousValue = Ifx_Oe_Osci_valueGet(&osci->channels[osci->trigger.source]);

            osci->stateChanged          = osci->trigger.source != osci->controlInterface.triggerSource;
        }

        osci->controlInterface.flags1           = 0;
        osci->controlInterface.bufferDepth      = 0;
        osci->controlInterface.triggerPosition  = 0;
        osci->controlInterface.triggerLevel     = 0;
        osci->controlInterface.samplingInterval = 0;
        osci->controlInterface.triggerSource    = 0;
        osci->controlInterface.reserved_2       = 0;
        osci->controlInterface.reserved_3       = 0;
        osci->controlInterface.reserved_4       = 0;

        /* Mark the data as free for write */
        osci->controlInterface.flags2 = 0;
    }
}


void Ifx_Oe_Osci_setRemoteControl(Ifx_Oe_Osci* osci, boolean value)
{
    boolean istate = Ifx_Oe_disableInterrupts();
    osci->controlInterface.remoteControlled = value ? 3 : 2;
    Ifx_Oe_restoreInterrupts(istate);
}


boolean Ifx_Oe_Osci_isStateChanged(Ifx_Oe_Osci* osci)
{
    boolean changed;
    boolean istate = Ifx_Oe_disableInterrupts();
    changed            = osci->stateChanged;
    osci->stateChanged = FALSE;
    Ifx_Oe_restoreInterrupts(istate);
    return changed;
}


void Ifx_Oe_Osci_setDataTransfered(Ifx_Oe_Osci* osci)
{
    boolean istate = Ifx_Oe_disableInterrupts();
    osci->controlInterface.dataTransfered = 1;
    osci->controlInterface.updateRequest  = 1;
    Ifx_Oe_restoreInterrupts(istate);
}


void Ifx_Oe_Osci_setControl(Ifx_Oe_Osci* osci, Ifx_Oe_Osci_ControlInterface* actions)
{
    boolean istate = Ifx_Oe_disableInterrupts();
    actions->updateRequest               = 0;
    osci->controlInterface               = *actions;
    osci->controlInterface.updateRequest = 1;
    Ifx_Oe_restoreInterrupts(istate);
}


/** \brief Run the oscilloscope */
void Ifx_Oe_Osci_start(Ifx_Oe_Osci* osci)
{
    boolean istate = Ifx_Oe_disableInterrupts();

    osci->controlInterface.enable        = 0x2 | 1;
    osci->controlInterface.updateRequest = 1;
    Ifx_Oe_restoreInterrupts(istate);
}


/** \brief Run the oscilloscope */
boolean Ifx_Oe_Osci_isRunning(Ifx_Oe_Osci* osci)
{
    return osci->enabled;
}


void Ifx_Oe_Osci_setDepth(Ifx_Oe_Osci* osci, uint32 depth)
{
    boolean istate = Ifx_Oe_disableInterrupts();

    osci->controlInterface.bufferDepth    = depth;
    osci->controlInterface.setBufferDepth = 1;
    osci->controlInterface.updateRequest  = 1;
    Ifx_Oe_restoreInterrupts(istate);
}


/** \brief Stop the oscilloscope */
void Ifx_Oe_Osci_stop(Ifx_Oe_Osci* osci)
{
    boolean istate = Ifx_Oe_disableInterrupts();

    osci->controlInterface.enable        = 0x2 | 0;
    osci->controlInterface.updateRequest = 1;
    Ifx_Oe_restoreInterrupts(istate);
}


/** \brief Set the trigger level */
void Ifx_Oe_Osci_setTriggerLevel(Ifx_Oe_Osci* osci, float32 level)
{
    boolean istate = Ifx_Oe_disableInterrupts();

    osci->controlInterface.triggerLevel    = level;
    osci->controlInterface.setTriggerLevel = 1;
    osci->controlInterface.updateRequest   = 1;
    Ifx_Oe_restoreInterrupts(istate);
}


/** \brief Set the trigger source */
void Ifx_Oe_Osci_setTriggerSource(Ifx_Oe_Osci* osci, uint16 channel)
{
    boolean istate = Ifx_Oe_disableInterrupts();

    osci->controlInterface.triggerSource    = channel;
    osci->controlInterface.setTriggerSource = 1;
    osci->controlInterface.updateRequest    = 1;
    Ifx_Oe_restoreInterrupts(istate);
}


void Ifx_Oe_Osci_setTriggerEdge(Ifx_Oe_Osci* osci, Ifx_Oe_Osci_TriggerEdge edge)
{
    boolean istate = Ifx_Oe_disableInterrupts();

    osci->controlInterface.triggerEdge   = 0x2 | edge;
    osci->controlInterface.updateRequest = 1;
    Ifx_Oe_restoreInterrupts(istate);
}


/** \brief Force trigger if trigger is enabled by Ifx_Oe_Osci_enableEdgeTrigger() */

void Ifx_Oe_Osci_forceTrigger(Ifx_Oe_Osci* osci)
{
    boolean istate = Ifx_Oe_disableInterrupts();

    osci->controlInterface.forceTrigger  = 1;
    osci->controlInterface.updateRequest = 1;
    Ifx_Oe_restoreInterrupts(istate);
}


void Ifx_Oe_Osci_setSamplingInterval(Ifx_Oe_Osci* osci, uint16 interval)
{
    boolean istate = Ifx_Oe_disableInterrupts();

    osci->controlInterface.samplingInterval    = interval;
    osci->controlInterface.setSamplingInterval = 1;
    osci->controlInterface.updateRequest       = 1;
    Ifx_Oe_restoreInterrupts(istate);
}


/** \brief Enable edge-triggering mode */
void Ifx_Oe_Osci_setTriggerSingle(Ifx_Oe_Osci* osci, boolean value)
{
    boolean istate = Ifx_Oe_disableInterrupts();

    osci->controlInterface.single        = 0x2 | (value ? 1 : 0);
    osci->controlInterface.updateRequest = 1;
    Ifx_Oe_restoreInterrupts(istate);
}


void Ifx_Oe_Osci_setTriggerMode(Ifx_Oe_Osci* osci, Ifx_Oe_Osci_TriggerMode mode)
{
    boolean istate = Ifx_Oe_disableInterrupts();

    osci->controlInterface.triggerMode   = 0x4 | mode;
    osci->controlInterface.updateRequest = 1;
    Ifx_Oe_restoreInterrupts(istate);
}


void Ifx_Oe_Osci_armTrigger(Ifx_Oe_Osci* osci)
{
    boolean istate = Ifx_Oe_disableInterrupts();
    osci->controlInterface.armTrigger    = 1;
    osci->controlInterface.updateRequest = 1;
    Ifx_Oe_restoreInterrupts(istate);
}


float32 Ifx_Oe_Osci_valueGet_Unknown(const Ifx_Oe_Osci_Signal* signal)           { return 0.0; }
float32 Ifx_Oe_Osci_valueGet_Float32(const Ifx_Oe_Osci_Signal* signal)           { return *((const float32*)signal->source); }
float32 Ifx_Oe_Osci_valueGet_SInt16(const Ifx_Oe_Osci_Signal* signal)            { return (float32)(*(const sint16*)signal->source); }
float32 Ifx_Oe_Osci_valueGet_UInt16(const Ifx_Oe_Osci_Signal* signal)            { return (float32)(*(const uint16*)signal->source); }
float32 Ifx_Oe_Osci_valueGet_SInt32(const Ifx_Oe_Osci_Signal* signal)            { return (float32)(*(const sint32*)signal->source); }
float32 Ifx_Oe_Osci_valueGet_UInt32(const Ifx_Oe_Osci_Signal* signal)            { return (float32)(*(const uint32*)signal->source); }
float32 Ifx_Oe_Osci_valueGet_FixPoint16(const Ifx_Oe_Osci_Signal* signal)        { return Ifx_Oe_fixpoint_to_float32((*(const sfract*)signal->source), signal->qFormatShift); }
float32 Ifx_Oe_Osci_valueGet_FixPoint32(const Ifx_Oe_Osci_Signal* signal)        { return Ifx_Oe_fixpoint_to_float32((*(const fract*)signal->source), signal->qFormatShift); }
float32 Ifx_Oe_Osci_valueGet_SInt8(const Ifx_Oe_Osci_Signal* signal)             { return (float32)(*(const sint8*)signal->source); }
float32 Ifx_Oe_Osci_valueGet_UInt8(const Ifx_Oe_Osci_Signal* signal)             { return (float32)(*(const uint8*)signal->source); }
float32 Ifx_Oe_Osci_valueGet_boolean(const Ifx_Oe_Osci_Signal* signal)           { return (float32)(*(boolean*)signal->source); }
float32 Ifx_Oe_Osci_valueGet_SInt64(const Ifx_Oe_Osci_Signal* signal)            { return (float32)(*(const sint64*)signal->source); }
float32 Ifx_Oe_Osci_valueGet_UInt64(const Ifx_Oe_Osci_Signal* signal)            { return (float32)(*(const uint64*)signal->source); }
float32 Ifx_Oe_Osci_valueGet_FctPtr_Float32(const Ifx_Oe_Osci_Signal* signal)    { return ((const float32 (*)(void))signal->source)(); }
float32 Ifx_Oe_Osci_valueGet_FctPtr_SInt16(const Ifx_Oe_Osci_Signal* signal)     { return (float32)((const sint16 (*)(void))signal->source)(); }
float32 Ifx_Oe_Osci_valueGet_FctPtr_UInt16(const Ifx_Oe_Osci_Signal* signal)     { return (float32)((const uint16 (*)(void))signal->source)(); }
float32 Ifx_Oe_Osci_valueGet_FctPtr_SInt32(const Ifx_Oe_Osci_Signal* signal)     { return (float32)((const sint32 (*)(void))signal->source)(); }
float32 Ifx_Oe_Osci_valueGet_FctPtr_UInt32(const Ifx_Oe_Osci_Signal* signal)     { return (float32)((const uint32 (*)(void))signal->source)(); }
float32 Ifx_Oe_Osci_valueGet_FctPtr_FixPoint16(const Ifx_Oe_Osci_Signal* signal) { return (float32)Ifx_Oe_fixpoint_to_float32(((const sfract (*)(void))signal->source)(), signal->qFormatShift); }
float32 Ifx_Oe_Osci_valueGet_FctPtr_FixPoint32(const Ifx_Oe_Osci_Signal* signal) { return (float32)Ifx_Oe_fixpoint_to_float32(((const fract (*)(void))signal->source)(), signal->qFormatShift); }
float32 Ifx_Oe_Osci_valueGet_FctPtr_SInt8(const Ifx_Oe_Osci_Signal* signal)      { return (float32)((const sint8 (*)(void))signal->source)(); }
float32 Ifx_Oe_Osci_valueGet_FctPtr_UInt8(const Ifx_Oe_Osci_Signal* signal)      { return (float32)((const uint8 (*)(void))signal->source)(); }
float32 Ifx_Oe_Osci_valueGet_FctPtr_boolean(const Ifx_Oe_Osci_Signal* signal)    { return (float32)((const boolean (*)(void))signal->source)(); }
float32 Ifx_Oe_Osci_valueGet_FctPtr_SInt64(const Ifx_Oe_Osci_Signal* signal)     { return (float32)((const sint64 (*)(void))signal->source)(); }
float32 Ifx_Oe_Osci_valueGet_FctPtr_UInt64(const Ifx_Oe_Osci_Signal* signal)     { return (float32)((const uint64 (*)(void))signal->source)(); }

float32(*Ifx_Oe_Osci_GetFctPtrArray[])(const Ifx_Oe_Osci_Signal * source) =
{
    Ifx_Oe_Osci_valueGet_Unknown,
    Ifx_Oe_Osci_valueGet_Float32,
    Ifx_Oe_Osci_valueGet_SInt16,
    Ifx_Oe_Osci_valueGet_UInt16,
    Ifx_Oe_Osci_valueGet_SInt32,
    Ifx_Oe_Osci_valueGet_UInt32,
    Ifx_Oe_Osci_valueGet_FixPoint16,
    Ifx_Oe_Osci_valueGet_FixPoint32,
    Ifx_Oe_Osci_valueGet_SInt8,
    Ifx_Oe_Osci_valueGet_UInt8,
    Ifx_Oe_Osci_valueGet_boolean,
    Ifx_Oe_Osci_valueGet_SInt64,
    Ifx_Oe_Osci_valueGet_UInt64,
    Ifx_Oe_Osci_valueGet_FctPtr_Float32,
    Ifx_Oe_Osci_valueGet_FctPtr_SInt16,
    Ifx_Oe_Osci_valueGet_FctPtr_UInt16,
    Ifx_Oe_Osci_valueGet_FctPtr_SInt32,
    Ifx_Oe_Osci_valueGet_FctPtr_UInt32,
    Ifx_Oe_Osci_valueGet_FctPtr_FixPoint16,
    Ifx_Oe_Osci_valueGet_FctPtr_FixPoint32,
    Ifx_Oe_Osci_valueGet_FctPtr_SInt8,
    Ifx_Oe_Osci_valueGet_FctPtr_UInt8,
    Ifx_Oe_Osci_valueGet_FctPtr_boolean,
    Ifx_Oe_Osci_valueGet_FctPtr_SInt64,
    Ifx_Oe_Osci_valueGet_FctPtr_UInt64,
};
