/**
 * \file ifx_oe_dasfifo.c
 * \brief Source file for our basebar on each display
 *
 *
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#include "ifx_oe_dasfifo.h"
#include "stdlib.h"
static inline boolean Ifx_Oe_DasFifo_CompareAndSet(volatile void* dst, uint32 old, uint32 new)
{
    return Ifx_Oe_cmpAndSwap((unsigned int*)dst, new, old) == old ? TRUE : FALSE;
}


static inline uint32 Ifx_Oe_DasFifo_Dist(uint32 high, uint32 low, uint32 size)
{
    uint32 res;

    if (high >= low)
    {
        res = high - low; /* res = size - high + low i.e. res = size + (-res) */
    }
    else
    {
        res = size - low + high; /* res = size - high + low i.e. res = size + (-res) */
    }

    return res;
}


Ifx_Oe_SizeT Ifx_Oe_DasFifo_write(
    Ifx_Oe_DasFifo* fifo,
    char* src,
    Ifx_Oe_SizeT count,
    Ifx_Oe_TickTime timeout)
{
    const uint32                   size   = fifo->size;
    Ifx_Oe_DasFifo_ToOneEye* const fifoTx = &fifo->tx;
    Ifx_Oe_DasFifo_ToOneEyeControl controlNew;
    Ifx_Oe_DasFifo_ToOneEyeControl controlOld;
    uint32                         freeElements;

    /* reserve buffer */
    do
    {
        do
        {
            controlOld             = fifoTx->control;
            controlNew             = controlOld;
            controlNew.data.active = controlNew.data.active + count;
            /* Note that readPos is not part of the Ifx_Oe_DasFifo_ToOneEyeControl structure. It is outside because it is accessed for write access only by OneEye
             * If OneEye writes concurrently (advances the readPos to be equal to writePos) the worst case is that we will believe that there is not enough memory, and iterate once in the loop for nothing.
             */
            uint32 pending = Ifx_Oe_DasFifo_Dist(controlOld.data.writepos, fifoTx->readPos, size);
            freeElements = (size - 1) - pending - controlOld.data.active; // -1 because we can't have the counter have same values after writing (would be same state as buffer empty)

            if (freeElements > count)
            {
                break;
            }
        } while (Ifx_Oe_Time_isDeadLine(timeout) == FALSE);

        if (freeElements <= count)
        {
            // timeout -> do not write
            return count;
        }
    } while (Ifx_Oe_DasFifo_CompareAndSet(&(fifoTx->control.value), controlOld.value, controlNew.value) == FALSE);

    /* write data */
    uint32 start = (controlOld.data.writepos + controlOld.data.active) % (size);
    uint32 stop  = start + count;

    for (uint32 i = start; i < stop; i++)
    {
        fifoTx->data[i % (size)] = src[i - start];
    }

    /* increment ready and notify that data is readable if possible */
    do
    {
        controlOld            = fifoTx->control;
        controlNew            = controlOld;
        controlNew.data.ready = controlNew.data.ready + count;

        if (controlNew.data.ready == controlNew.data.active)
        {
            /* we're the last writer, mark data as readable */
            controlNew.data.writepos = (controlNew.data.writepos + controlNew.data.active) % (size);
            controlNew.data.active   = 0;
            controlNew.data.ready    = 0;
        }
    } while (Ifx_Oe_DasFifo_CompareAndSet(&fifoTx->control.value, controlOld.value, controlNew.value) == FALSE);

    return 0;
}


Ifx_Oe_SizeT Ifx_Oe_DasFifo_read(Ifx_Oe_DasFifo* fifo, char* dst, Ifx_Oe_SizeT* count, Ifx_Oe_TickTime timeout)
{
    const uint32                     size   = fifo->size;
    Ifx_Oe_DasFifo_FromOneEye* const fifoRx = &fifo->rx;
    /* OneEye will no access rxPending as long as it's not empty, so protected access is not required. It is assumed FifoRead is called in only one context on the target */
    // Find number of readable bytes (limited either by count or actually pending bytes)
    uint32 pending  = Ifx_Oe_DasFifo_Dist(fifoRx->control.rxEnd, fifoRx->control.rxBeg, size);
    uint32 readable = IFX_OE_MIN(*count, pending);

    if (readable > 0)
    {
        // Copy data
        for (uint32 i = fifoRx->control.rxBeg; i < fifoRx->control.rxBeg + readable; i++)
        {
            dst[i - fifoRx->control.rxBeg] = fifoRx->data[i % size];
        }

        fifoRx->control.rxBeg = (fifoRx->control.rxBeg + readable) % size;
    }

    *count = (Ifx_Oe_SizeT)readable;
    return (Ifx_Oe_SizeT)(pending - readable);
}


void Ifx_Oe_DasFifo_clearRx(Ifx_Oe_DasFifo* fifo)
{
    fifo->rx.control.rxBeg = 0;
    fifo->rx.control.rxEnd = 0;
}


void Ifx_Oe_DasFifo_clearTx(Ifx_Oe_DasFifo* fifo)
{
    Ifx_Oe_DasFifo_ToOneEyeControl controlNew;
    Ifx_Oe_DasFifo_ToOneEyeControl controlOld;

    do
    {
        controlOld       = fifo->tx.control;
        controlNew.value = 0;
    } while (Ifx_Oe_DasFifo_CompareAndSet(&fifo->tx.control.value, controlOld.value, controlNew.value) == FALSE);
}


void Ifx_Oe_DasFifo_initConfig(Ifx_Oe_DasFifo_Config* config)
{
    config->size = 512;
}


boolean Ifx_Oe_DasFifo_init(Ifx_Oe_DasFifo* fifo, Ifx_Oe_DasFifo_Config* config)
{
    if (config->size > 1024)
    {
        return FALSE;
    }

    fifo->rx.data = (char*)malloc(config->size);
    fifo->tx.data = (char*)malloc(config->size);

    if ((fifo->rx.data == NULL_PTR) || (fifo->tx.data == NULL_PTR))
    {
        fifo->size = 0;
        free(fifo->rx.data);
        free(fifo->tx.data);
        return FALSE;
    }

    fifo->size = config->size;
    return TRUE;
}
