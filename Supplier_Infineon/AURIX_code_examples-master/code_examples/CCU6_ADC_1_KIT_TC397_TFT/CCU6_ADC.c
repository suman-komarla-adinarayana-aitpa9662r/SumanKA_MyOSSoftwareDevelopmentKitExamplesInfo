/**********************************************************************************************************************
 * \file CCU6_ADC.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "CCU6_ADC.h"
#include "Ifx_Types.h"
#include "IfxAsclin_Asc.h"
#include "IfxCcu6_Timer.h"
#include "IfxEvadc_Adc.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ISR_PRIORITY_ADC                4                               /* ADC result interrupt's priority          */
#define ADC_CHANNEL                     0                               /* ADC channel number                       */
#define ADC_GROUP                       IfxEvadc_GroupId_0              /* EVADC group                              */
#define ENABLE_EXTERNAL_TRIGGER         0x80                            /* Mask to enable external triggers on ADC  */

#define ISR_PRIORITY_ASCLIN_TX          1                               /* Priority of the interrupt ISR Transmit   */
#define ISR_PRIORITY_ASCLIN_RX          2                               /* Priority of the interrupt ISR Receive    */
#define ISR_PRIORITY_ASCLIN_ER          3                               /* Priority of the interrupt ISR Errors     */
#define ASC_TX_BUFFER_SIZE              64
#define ASC_RX_BUFFER_SIZE              64
#define ASC_PRESCALER                   1
#define ASC_BAUDRATE                    115200

#define CCU6_T12_TIMER_FREQ             48828                           /* T12 Timer module frequency in Hz         */
#define CCU6_T13_TIMER_FREQ             48828                           /* T13 Timer module frequency in Hz         */
#define CCU6_T12_TIMER_MATCH_FREQ       1                               /* T12 Period Match frequency in Hz         */
#define CCU6_T13_TIMER_MATCH_PERIOD     0.5f                            /* T13 Period Match time in seconds         */

/* Timers period in ticks */
#define CCU6_T12_TIMER_PERIOD           (CCU6_T12_TIMER_FREQ / CCU6_T12_TIMER_MATCH_FREQ) - 1
#define CCU6_T13_TIMER_PERIOD           (CCU6_T13_TIMER_FREQ * CCU6_T13_TIMER_MATCH_PERIOD) - 1

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
 /* EVADC handle */
IfxEvadc_Adc         g_evadc;
IfxEvadc_Adc_Group   g_adcGroup;
IfxEvadc_Adc_Channel g_adcChannel;

/* Timer handle */
IfxCcu6_Timer g_timer;

/* Variable for Standard interface */
IfxAsclin_Asc g_asc;
IfxStdIf_DPipe g_stdInterface;

/* The transfer buffers allocate memory for the data itself and for the FIFO runtime variables.
 * 8 more bytes have to be added to ensure a proper circular buffer handling independent from
 * the address to which the buffers have been located.
 */
uint8 g_AscTxBuffer[ASC_TX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];
uint8 g_AscRxBuffer[ASC_RX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Function to initialize the CCU6 module */
void init_CCU6(void)
{
    IfxCcu6_Timer_Config timerConfig;
    IfxCcu6_Timer_initModuleConfig(&timerConfig, &MODULE_CCU60);

    /* Configure the T12 timer frequency/period (trigger for T13 timer) and T13 timer frequency/period (trigger
     * for ADC). Timer T13 starts counting in single shot mode triggered by a period-match event of the T12 timer.
     * The period of the timer T13 represents a delay (from the period-match event of the T12 timer) of the ADC
     * trigger event.
     */
    timerConfig.base.t12Frequency = CCU6_T12_TIMER_FREQ;                /* Timer T12 frequency                      */
    timerConfig.base.waitingTime = CCU6_T12_TIMER_PERIOD;               /* waitingTime is the period of T12 timer   */
    timerConfig.base.t13Frequency = CCU6_T13_TIMER_FREQ;                /* Timer T13 frequency                      */
    timerConfig.base.t13Period = CCU6_T13_TIMER_PERIOD;                 /* Timer T13 period                         */
    timerConfig.timer = IfxCcu6_TimerId_t13;                            /* Select the timer, T13 is the master      */
    timerConfig.synchronousOperation = FALSE;                           /* Disable synchronous start of the timers  */
    timerConfig.trigger.t13InSyncWithT12 = TRUE;                        /* T12 timer starts the T13 timer           */

    /* Configure the T13 timer start event */
    timerConfig.timer13.t12SyncEvent = IfxCcu6_T13TriggerEvent_onT12Period;
    timerConfig.timer13.t12SyncDirection = IfxCcu6_T13TriggerDirection_onT12CountingUp;

    /* Apply the configuration to the CCU6 module */
    IfxCcu6_Timer_initModule(&g_timer, &timerConfig);

    /* Activate the line ServiceRequest_3 to route the T13 period match event trigger to the EVADC module */
    IfxCcu6_enableInterrupt(&MODULE_CCU60, IfxCcu6_InterruptSource_t13PeriodMatch);
    IfxCcu6_routeInterruptNode(&MODULE_CCU60, IfxCcu6_InterruptSource_t13PeriodMatch, IfxCcu6_ServiceRequest_3);

    /* Configure the T13 timer for single shot mode */
    IfxCcu6_enableSingleShotMode(&MODULE_CCU60, IfxCcu6_TimerId_t13);
}

/* Function to start the CCU6 timer, according to the configuration */
void start_CCU6_timer(void)
{
    IfxCcu6_Timer_start(&g_timer);
}

/* Function to initialize the EVADC with default parameters */
void init_EVADC()
{
    init_EVADC_module();    /* Initialize the EVADC module */
    init_EVADC_group();     /* Initialize the EVADC group  */
    init_EVADC_channels();  /* Initialize the channels     */
}

/* Function to initialize the EVADC module with default parameters */
void init_EVADC_module()
{
    /* Create configuration */
    IfxEvadc_Adc_Config adcConfig;
    IfxEvadc_Adc_initModuleConfig(&adcConfig, &MODULE_EVADC);

    /* Initialize module */
    IfxEvadc_Adc_initModule(&g_evadc, &adcConfig);
}

/* Function to initialize the EVADC group */
void init_EVADC_group()
{
    /* Create and initialize group configuration with default values */
    IfxEvadc_Adc_GroupConfig adcGroupConfig;
    IfxEvadc_Adc_initGroupConfig(&adcGroupConfig, &g_evadc);

    /* Setting user configuration using group 0 */
    adcGroupConfig.groupId = ADC_GROUP;
    adcGroupConfig.master = adcGroupConfig.groupId;

    /* Enable queue 0 source */
    adcGroupConfig.arbiter.requestSlotQueue0Enabled = TRUE;

    /* Enable all gates in "always" mode (no edge detection) */
    adcGroupConfig.queueRequest[0].triggerConfig.gatingMode = IfxEvadc_GatingMode_always;

    /* Configure the EVADC module to trigger a conversion based on CCU6 timer period match event */
    /* Trigger 0 is connected to CCU6 ServiceRequest_3 line */
    adcGroupConfig.queueRequest[0].triggerConfig.triggerSource = IfxEvadc_TriggerSource_0;

    /* Select the trigger event type */
    adcGroupConfig.queueRequest[0].triggerConfig.triggerMode = IfxEvadc_TriggerMode_uponRisingEdge;

    /* Set that requests with higher priority cancel a running lower priority conversion */
    adcGroupConfig.queueRequest[0].requestSlotStartMode = IfxEvadc_RequestSlotStartMode_cancelInjectRepeat;

    /* Initialize the group */
    IfxEvadc_Adc_initGroup(&g_adcGroup, &adcGroupConfig);
}

/* Function to initialize the EVADC channel */
void init_EVADC_channels()
{
    /* Create channel configuration */
    IfxEvadc_Adc_ChannelConfig adcChannelConfig;

    IfxEvadc_Adc_initChannelConfig(&adcChannelConfig, &g_adcGroup);

    adcChannelConfig.channelId = (IfxEvadc_ChannelId)(ADC_CHANNEL);
    adcChannelConfig.resultRegister = (IfxEvadc_ChannelResult)(ADC_CHANNEL);

    /* Interrupt for sending the data via UART */
    adcChannelConfig.resultPriority = ISR_PRIORITY_ADC;                 /* Set the EVADC interrupt priority          */
    adcChannelConfig.resultServProvider = IfxSrc_Tos_cpu0;              /* Set the EVADC interrupt service provider  */

    /* Initialize the channel */
    IfxEvadc_Adc_initChannel(&g_adcChannel, &adcChannelConfig);

    /* Add channel to queue with refill and external trigger enabled */
    IfxEvadc_Adc_addToQueue(&g_adcChannel, IfxEvadc_RequestSource_queue0, (ENABLE_EXTERNAL_TRIGGER | IFXEVADC_QUEUE_REFILL));
}

/* ADC Interrupt Service Routine */
IFX_INTERRUPT(ISR_ADC_result, 0, ISR_PRIORITY_ADC);

void ISR_ADC_result(void)
{
    /* Get the result from the EVADC result register and print it using the UART communication */
    Ifx_EVADC_G_RES conversionResult = IfxEvadc_Adc_getResult(&g_adcChannel);
    IfxStdIf_DPipe_print(&g_stdInterface, "ADC Sample: %d\r\n", conversionResult.B.RESULT);
}

/* ASCLIN TX Interrupt Service Routine */
IFX_INTERRUPT(ISR_ASCLIN_Tx, 0, ISR_PRIORITY_ASCLIN_TX);

void ISR_ASCLIN_Tx(void)
{
    IfxStdIf_DPipe_onTransmit(&g_stdInterface);
}

/* ASCLIN RX Interrupt Service Routine */
IFX_INTERRUPT(ISR_ASCLIN_Rx, 0, ISR_PRIORITY_ASCLIN_RX);

void ISR_ASCLIN_Rx(void)
{
    IfxStdIf_DPipe_onReceive(&g_stdInterface);
}

/* ASCLIN Error Interrupt Service Routine */
IFX_INTERRUPT(ISR_ASCLIN_Er, 0, ISR_PRIORITY_ASCLIN_ER);

void ISR_ASCLIN_Er(void)
{
    IfxStdIf_DPipe_onError(&g_stdInterface);
}

/* Function to initialize ASCLIN module */
void init_UART(void)
{
    IfxAsclin_Asc_Config ascConf;

    IfxAsclin_Asc_initModuleConfig(&ascConf, &MODULE_ASCLIN0);

    /* Set the desired baud rate */
    ascConf.baudrate.prescaler = ASC_PRESCALER;
    ascConf.baudrate.baudrate = ASC_BAUDRATE;
    ascConf.baudrate.oversampling = IfxAsclin_OversamplingFactor_16;            /* Set the oversampling factor      */

    /* Configure the sampling mode */
    ascConf.bitTiming.medianFilter = IfxAsclin_SamplesPerBit_three;             /* Set the number of samples per bit*/
    ascConf.bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_8;    /* Set the first sample position    */

    /* ISR priorities and interrupt target */
    ascConf.interrupt.txPriority = ISR_PRIORITY_ASCLIN_TX;
    ascConf.interrupt.rxPriority = ISR_PRIORITY_ASCLIN_RX;
    ascConf.interrupt.erPriority = ISR_PRIORITY_ASCLIN_ER;
    ascConf.interrupt.typeOfService = IfxSrc_Tos_cpu0;

    /* FIFO configuration */
    ascConf.txBuffer = g_AscTxBuffer;
    ascConf.txBufferSize = ASC_TX_BUFFER_SIZE;
    ascConf.rxBuffer = g_AscRxBuffer;
    ascConf.rxBufferSize = ASC_RX_BUFFER_SIZE;

    /* Pin configuration */
    const IfxAsclin_Asc_Pins pins = {
            NULL, IfxPort_InputMode_pullUp,                                       /* CTS port pin not used            */
            &IfxAsclin0_RXA_P14_1_IN, IfxPort_InputMode_pullUp,                   /* RX port pin                      */
            NULL, IfxPort_OutputMode_pushPull,                                    /* RTS port pin not used            */
            &IfxAsclin0_TX_P14_0_OUT, IfxPort_OutputMode_pushPull,                /* TX port pin                      */
            IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConf.pins = &pins;

    /* Initialize the module */
    IfxAsclin_Asc_initModule(&g_asc, &ascConf);

    /* Initialize the Standard Interface */
    IfxAsclin_Asc_stdIfDPipeInit(&g_stdInterface, &g_asc);
}
