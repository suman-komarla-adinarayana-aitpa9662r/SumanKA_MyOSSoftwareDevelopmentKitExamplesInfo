<img src="./Images/IFX_LOGO_600.gif" align="right" width="150" />  

# iLLD_TC397_ADS_SD_Read_To_Serial
**A text file is read from a Secure Digital (SD) card and its content is printed to the serial terminal.**

## Device  
The device used in this example is AURIX&trade; TC39xXX_B-Step.  

## Board  
The board used for testing is the APPLICATION KIT TC3X7 V2.0 (KIT_A2G_TC397_5V_TFT).  

## Scope of work
A text file is read from an SD card using the Queued Serial Peripheral Interface (QSPI) protocol and the FatFS library.
The text taken from the file is the sent to the serial terminal.

## Introduction  
- For this example, a simple, lightweight library is used for accessing the File Allocation Table (FAT) File System (FS) of the SD card and reads a text file
- The content of the file is then streamed to the user through serial terminal
- Specific *serialio* library to override *printf()* behavior is provided for the scope
- The library used for implementing the FAT file system is called *FatFS*, and can be  taken from  ELM ChaN web site under "Softwares > FatFS Module"

## Hardware setup  
This code example has been developed for the APPLICATION KIT TC3X7 V2.0 (KIT_A2G_TC397_5V_TFT).  
The board should be connected to the PC via USB, in order to allow the UART connection. 

<img src="./Images/Application Kit_TC3xx_Board_top.PNG" width="600" />   

A microSD card shall be installed in the SD slot of the board.  
The card must be formatted as FAT32 and shall contain a file named *messages.txt*, which should contain some text.  

## Implementation  
**Configure the Project**  
Two libraries are required, which can be found in the *Libraries* folder:
- *serialio*, which overrides the standard *printf()* function to redirect the output to the serial terminal
- *FatFS*, which contains the library to read the file system from the SD card

**A look into the low level disk interface**  
The link between the *FatFS* library and the AURIX&trade; hardware is contained in the files *Libraries/FatFS/mmc_qspi.c*.  
This file "translates" every *FatFS* file system operation into the corresponding AURIX&trade; QSPI commands for the SD card.

**Periodically servicing the SD**  
The *FatFS* library requires periodically calling the function *disk_timerproc()* to generate timing and to service the SD card.
This is done using an *IFX_INTERRUPT* generated by the System Timer Module (STM). 

**Configure the ASCLIN**  
The ASCLIN (Asynchronous/Synchronous Interface) module is necessary to implement the serial communication with the terminal.

Configuration of the ASCLIN module for UART communication is done in the function *SERIALIO_Init()*, it takes the desired UART baudrate as parameter.  
The desired baudrate can be defined with the macro *UART_BAUDRATE*, whose default value is set to 115200 baud.

**Mounting the SD Card**  
Mounting the SD card is done by calling the *FatFS* function *f_mount()*. This function takes a reference to a *FATFS* variable, which represents the whole
file system contained in the SD card.

**Opening the messages.txt file**  
Once the file system is successfully mounted, it is possible to read its content. In particular, the program searches for the file *messages.txt*, which is 
expected to be found in the root of the file system.  
This is done by calling the function *f_open()*. It allows the user also to specify which mode to use to open a file. In our case the file *messages.txt* is
opened read-only (*FA_READ*) and a handle to it is created in the variable *fil*.

**Reading the file**  
It is now possible to read the content of the file. The function *f_gets()* reads a string from the given file handle. The strings are considered delimited by 
a carriage return or a newline character, and the file handle is treated as a stream. Reading a string "consumes" its content until there is nothing more to
read.

**Closing the file**  
Once the text has been completely read, the file is closed calling *f_close()*. This operation releases all locks on the file, and if it was opened in write mode,
it would also flush any cached data to the SD card.

## Compiling and programming
Before testing this code example:
- Power the board through the dedicated power connector
- Connect the board to the PC through the USB interface
- Build the project using the dedicated Build button <img src="./Images/build_activeproj.gif" /> or by right-clicking the project name and selecting "Build Project"
- To flash the device and immediately run the program, click on the dedicated Flash button <img src="./Images/micro.png" />

## Run and Test  
For this example, a serial terminal is required for visualizing the text. The terminal can be opened inside the AURIX&trade; Development Studio using the following icon:  

<img src="./Images/UART_Terminal.gif" width="800" />  

The serial terminal must be configured with the following parameters to enable the communication between the board and the PC:  
- Speed (baud): 115200
- Data bits: 8
- Stop bit: 1

After code compilation and flashing the device, check the open terminal window on AURIX&trade; Development Studio, which looks like the following:  

<img src="./Images/serial-output.png" width="500" />  

Please note that the console output depends on the content of your *messages.txt* file, and might not match the one in the picture.  

## References  

AURIX&trade; Development Studio is available online:  
- <https://www.infineon.com/aurixdevelopmentstudio>  
- Use the "Import..." function to get access to more code examples  

More code examples can be found on the GIT repository:  
- <https://github.com/Infineon/AURIX_code_examples>  

For additional trainings, visit our webpage:  
- <https://www.infineon.com/aurix-expert-training>  

For questions and support, use the AURIX&trade; Forum:  
- <https://community.infineon.com/t5/AURIX/bd-p/AURIX>  
