/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
 /*\title Read from SD card and print to serial terminal
 * \abstract A text file is read from an Secure Digital (SD) card and its content is printed to the serial terminal.
 * \description A text file is read from a SD card using the Queued Serial Peripheral Interface (QSPI) protocol and the FatFS library.
 *              The text taken from the file is the sent to the serial terminal.
 *
 * \name iLLD_TC397_ADS_SD_Read_To_Serial
 * \version V1.0.0
 * \board APPLICATION KIT TC3X7 V2.0, KIT_A2G_TC397_5V_TFT, TC39xXX_B-Step
 * \keywords SDCard, Serial, FatFS, File, Terminal
 * \lastUpdated 2023-05-29
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include "IfxStm.h"
#include "Configuration.h"
#include "ConfigurationIsr.h"
#include "serialio.h"
#include "ff.h"

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/*
 * Configuration of UART pin and module
 */
SERIALIO_t SERIALIO =
{
  .asclin = &MODULE_ASCLIN0,
  .tx_pin = &IfxAsclin0_TX_P14_0_OUT,
  .rx_pin = &IfxAsclin0_RXA_P14_1_IN
};

IFX_ALIGN(4) IfxCpu_syncEvent g_cpuSyncEvent = 0;
uint32 g_TickCount_1ms;
FATFS g_FatFs;   /* Work area (filesystem object) for logical drive */

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
/* UART baud rate in bit/s */
#define UART_BAUDRATE 115200

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
IFX_EXTERN void disk_timerproc(void);
void print_result(FRESULT fr);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
IFX_INTERRUPT (UsrIsr_Stm_0, 0, ISR_PRIORITY_OS_TICK)
{
    /* Set next 1ms scheduler tick alarm */
    IfxStm_increaseCompare(&MODULE_STM0, IfxStm_Comparator_0, IFX_CFG_STM_TICKS_PER_MS);

    /* Increase tick count by 1ms */
    g_TickCount_1ms++;

    /* Enable the global interrupts of this CPU */
    IfxCpu_enableInterrupts();

    /* Action to do each 10ms */
    if ((g_TickCount_1ms % 10) == 0)
    {
        disk_timerproc(); /* Call the disc timer procedure each 10ms to calculate the timeouts */
    }
}

void core0_main(void)
{
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
    
    /* Enable the global interrupts of this CPU */
    IfxCpu_enableInterrupts();

    /* Initialize STM */
    IfxStm_CompareConfig stmCompareConfig;

    /* Suspend by debugger enabled */
    IfxStm_enableOcdsSuspend(&MODULE_STM0);

    /* Constructor of configuration */
    IfxStm_initCompareConfig(&stmCompareConfig);

    /* Change the comparator configuration */
    stmCompareConfig.triggerPriority      = ISR_PRIORITY_OS_TICK;
    stmCompareConfig.comparatorInterrupt  = IfxStm_ComparatorInterrupt_ir0; /* User must select the interrupt output */
    stmCompareConfig.ticks                = IFX_CFG_STM_TICKS_PER_MS*10;    /* Start after 10ms */
    stmCompareConfig.typeOfService        = IfxSrc_Tos_cpu0;

    /* Now Compare functionality is initialized */
    IfxStm_initCompare(&MODULE_STM0, &stmCompareConfig);
    
    /* Initialize Serial Output */
    SERIALIO_Init(UART_BAUDRATE);

    FIL fil;        /* File object */
    char line[100]; /* Line buffer */
    FRESULT fr;     /* FatFs return code */

    printf("Mount SD card: ");
    /* Give a work area to the default drive */
    fr = f_mount(&g_FatFs, "", 0);
    print_result(fr);
    printf("\n\r");
    if (fr)
    {
        return;
    }

    printf("Open file messages.txt: ");
    /* Open a text file */
    fr = f_open(&fil, "messages.txt", FA_READ);
    print_result(fr);
    printf("\n\r");
    if (fr)
    {
        return;
    }

    printf("Read every line and display it\n\n\r");
    /* Read every line and display it */
    while (f_gets(line, sizeof line, &fil))
    {
        printf(line);
    }

    printf("\n\rClose file messages.txt: ");
    /* Close the file */
    fr = f_close(&fil);
    print_result(fr);
    printf("\n\r");

    while(1)
    {
    }
}

void print_result(FRESULT fr)
{
    switch(fr)
    {
        case FR_OK:
            printf("Succeeded");
            break;
        case FR_DISK_ERR:
            printf("hard error occurred in the low level disk I/O layer");
            break;
        case FR_INT_ERR:
            printf("Assertion failed");
            break;
        case FR_NOT_READY:
            printf("The physical drive cannot work");
            break;
        case FR_NO_FILE:
            printf("Could not find the file");
            break;
        case FR_NO_PATH:
            printf("Could not find the path");
            break;
        case FR_INVALID_NAME:
            printf("The path name format is invalid");
            break;
        case FR_DENIED:
            printf("Access denied due to prohibited access or directory full");
            break;
        case FR_EXIST:
            printf("Access denied due to prohibited access");
            break;
        case FR_INVALID_OBJECT:
            printf("The file/directory object is invalid");
            break;
        case FR_WRITE_PROTECTED:
            printf("The physical drive is write protected");
            break;
        case FR_INVALID_DRIVE:
            printf("The logical drive number is invalid");
            break;
        case FR_NOT_ENABLED:
            printf("The volume has no work area");
            break;
        case FR_NO_FILESYSTEM:
            printf("There is no valid FAT volume");
            break;
        case FR_MKFS_ABORTED:
            printf("The f_mkfs() aborted due to any problem");
            break;
        case FR_TIMEOUT:
            printf("Could not get a grant to access the volume within defined period");
            break;
        case FR_LOCKED:
            printf("The operation is rejected according to the file sharing policy");
            break;
        case FR_NOT_ENOUGH_CORE:
            printf("LFN working buffer could not be allocated");
            break;
        case FR_TOO_MANY_OPEN_FILES:
            printf("Number of open files > FF_FS_LOCK");
            break;
        case FR_INVALID_PARAMETER:
            printf("Given parameter is invalid");
            break;
        default:
            printf("Unknown error");
    }
}
