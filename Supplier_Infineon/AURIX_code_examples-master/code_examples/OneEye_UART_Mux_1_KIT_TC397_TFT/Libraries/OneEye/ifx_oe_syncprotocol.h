/**
 * \file ifx_oe_syncprotocol.h
 *
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */
#ifndef IFX_OE_SYNCPROTOCOL_H
#define IFX_OE_SYNCPROTOCOL_H

#define IFX_OE_SYNCPROTOCOL_VARIANT_QT    (1)
#define IFX_OE_SYNCPROTOCOL_VARIANT_AURIX (2)
#ifndef IFX_OE_SYNCPROTOCOL_VARIANT
#define IFX_OE_SYNCPROTOCOL_VARIANT IFX_OE_SYNCPROTOCOL_VARIANT_AURIX
#endif
/** Synchron, symetric binary protocol with handchecking
 *
 *
 * Features
 * - Data stream synchronisation by header and header checksum
 * - Symetrical protocol (No master / slave)
 * - Messages are send from a sender to a receiver linked by local and remote ports (Communication channels)
 * - Messages are split in multiple frames depending on the message size
 * - Frames have an header and payload checksum
 * - Frame header and payload acknowledge
 * - One message is buffered for send per port
 * - Resend frame header on error
 * - Resend frame payload on error
 * - Send and receive timeout
 *
 *
 * Frame use case :
 * 1) A sends, B acknowledge
 * A: Header - ... - PAYLOAD - ...
 * B: ...... - ACK - ....... - ACK
 *
 * 2) A and B sends at the same time
 * A: Header - ACK + PAYLOAD - ACK
 * B: Header - ACK + PAYLOAD - ACK
 *
 * 3) A and B sends at the same time
 * A: Header - ... - ACK + PAYLOAD - ACK
 * B: Header - ACK - ... - PAYLOAD - ACK
 *
 * 4) A sends, B acknowledge, error in header
 * A: Header - .... - HEADER - ... - PAYLOAD - ...
 * B: ...... - ACKN - ...... - ACK - ....... - ACK
 *
 * 5) A sends, B acknowledge, error in payload
 * A: Header - ... - PAYLOAD - .... - PAYLOAD - ...
 * B: ...... - ACK - ....... - ACKN - ....... - ACK
 *
 * 6) A sends, B does not acknowledge the header
 * A: Header - .................... (TIMEOUT)
 * B: ...... - ....................
 *
 * 7) A sends, B does not acknowledge the payload
 * A: Header - ... - PAYLOAD - .................... (TIMEOUT)
 * B: ...... - ACK - ....... - ............................ (TIMEOUT)
 *
 */
/*************************************/
#if IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_QT
/* QT */
#include "fifo.h"
#include "fifodpipe.h"

#define FALSE (false)
#define TRUE  (true)
#define IFX_OE_SYNCPROTOCOL_NULL  (nullptr)

typedef qint8  sint8;
typedef qint16 sint16;
typedef qint32 sint32;
typedef qint64 sint64;

typedef quint8  uint8;
typedef quint16 uint16;
typedef quint32 uint32;
typedef quint64 uint64;
typedef float   float32;
typedef bool    boolean;

typedef sint64           Ifx_Oe_SyncProtocol_Time;
typedef Fifo             Ifx_Oe_SyncProtocol_Fifo;
typedef FifoDPipe            Ifx_Oe_SyncProtocol_DPipe;
typedef FifoDPipe   Ifx_Oe_SyncProtocol_DPipeStdIf;
typedef Fifo::BufferSize Ifx_Oe_SyncProtocol_FifoSize;

#elif IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_AURIX

#include "ifx_oe_fifo.h"
#include "ifx_oe_fifodpipe.h"
#include "ifx_oe_dpipewrapper.h"
#include "stddef.h"

typedef Ifx_Oe_TickTime  Ifx_Oe_SyncProtocol_Time;
typedef Ifx_Oe_Fifo      Ifx_Oe_SyncProtocol_Fifo;
typedef Ifx_Oe_FifoDPipe Ifx_Oe_SyncProtocol_DPipe;
typedef IfxStdIf_DPipe   Ifx_Oe_SyncProtocol_DPipeStdIf;
typedef Ifx_Oe_SizeT     Ifx_Oe_SyncProtocol_FifoSize;

#ifndef IFX_OE_SYNCPROTOCOL_PRIVATE_HEAP_SIZE
/** Use own private heap to protect access when used at different interrupt levels
 * The heap is used to allocate memory for message data
 * Set to 0 to disable private heap
 */
#define IFX_OE_SYNCPROTOCOL_PRIVATE_HEAP_SIZE (0)
#endif
#define IFX_OE_SYNCPROTOCOL_NULL  (NULL_PTR)

#endif

#if (IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_AURIX) && (IFX_OE_SYNCPROTOCOL_PRIVATE_HEAP_SIZE != 0)
#define IFX_OE_SYNCPROTOCOL_USE_PRIVATE_HEAP 1
#include "ifx_oe_malloc.h"
#else
#define IFX_OE_SYNCPROTOCOL_USE_PRIVATE_HEAP 0
typedef void* Ifx_Oe_Malloc_Pool;

#endif

#ifdef __cplusplus
extern "C" {
#endif

/*-------------------------------------------------------------------------*/
/* Ifx_Oe_SyncProtocol: Frame                                                     */
/*-------------------------------------------------------------------------*/
#define IFX_OE_SYNCPROTOCOL_VERSION            0x01
#define IFX_OE_SYNCPROTOCOL_PASSWORD           0x12345679
#define IFX_OE_SYNCPROTOCOL_HEADER_START_BYTE  0xDE
#define IFX_OE_SYNCPROTOCOL_PAYLOAD_START_BYTE 0xDF

/** Maximum frame index value. must be (x^2)-1, where x is an integer */
#define IFX_OE_SYNCPROTOCOL_FRAME_MAX_INDEX     0x15
#define IFX_OE_SYNCPROTOCOL_FRAME_INDEX_INVALID 0x0

typedef uint8 Ifx_Oe_SyncProtocol_Port;
/** Max number of client. Range=[0,31] */
#define IFX_OE_SYNCPROTOCOL_PORT_MAX  10
#define IFX_OE_SYNCPROTOCOL_PORT_CORE 0x0
#define IFX_OE_SYNCPROTOCOL_PORT_NONE 0xFF

typedef enum
{
    /** Value for Ifx_Oe_SyncProtocol_FrameFlags.B.ack: No acknowledge information in header */
    Ifx_Oe_SyncProtocol_Ack_none = 0x0,
    /** Value for Ifx_Oe_SyncProtocol_FrameFlags.B.ack: The header is invalid */
    Ifx_Oe_SyncProtocol_Ack_headerError = 0x1,
    /** Value for Ifx_Oe_SyncProtocol_FrameFlags.B.ack: The port is not connected */
    Ifx_Oe_SyncProtocol_Ack_portClosed = 0x2,
    /** Value for Ifx_Oe_SyncProtocol_FrameFlags.B.ack: The driver is busy receiving a frame on the port */
    Ifx_Oe_SyncProtocol_Ack_busy = 0x3,
    /** Value for Ifx_Oe_SyncProtocol_FrameFlags.B.ack: The header is valid, frame acknowleged  */
    Ifx_Oe_SyncProtocol_Ack_headerOk = 0x4,
    /** Value for Ifx_Oe_SyncProtocol_FrameFlags.B.ack: The payload checksum is incorrect */
    Ifx_Oe_SyncProtocol_Ack_payloadError = 0x5,
    /** Value for Ifx_Oe_SyncProtocol_FrameFlags.B.ack: The paylaod checksum is correct */
    Ifx_Oe_SyncProtocol_Ack_payloadOk = 0x6,
}Ifx_Oe_SyncProtocol_Ack;

typedef enum
{
    Ifx_Oe_SyncProtocol_FrameType_ack        = 0x0,
    Ifx_Oe_SyncProtocol_FrameType_data       = 0x1,
    Ifx_Oe_SyncProtocol_FrameType_dataStart  = 0x2,
    Ifx_Oe_SyncProtocol_FrameType_dataMiddle = 0x3,
    Ifx_Oe_SyncProtocol_FrameType_dataEnd    = 0x4,
}Ifx_Oe_SyncProtocol_FrameType;

typedef union
{
    uint16 U;
    struct
    {
        uint8 b0;
        uint8 b1;
    }X;
    struct
    {
        uint16 frameType : 3;
#define Ifx_Oe_SyncProtocol_FrameType_ack        0x0
#define Ifx_Oe_SyncProtocol_FrameType_data       0x1
#define Ifx_Oe_SyncProtocol_FrameType_dataStart  0x2
#define Ifx_Oe_SyncProtocol_FrameType_dataMiddle 0x3
#define Ifx_Oe_SyncProtocol_FrameType_dataEnd    0x4
        uint16 ack : 3;
        /**
         * @brief Index of the acknowlegde frame
         */
        uint16 indexAck : 4;
        /** the packet Index references the packet in a packet stream, the 1st
         * packet of the same data get the index 0, the 2nd index 1, ....
         * on overflow, the index starts at 0 again */
        uint16 index : 4;
        uint16 reserved : 2;
    }B;
}Ifx_Oe_SyncProtocol_FrameFlags;

typedef unsigned char Ifx_Oe_SyncProtocol_ChecksumHeader;
typedef unsigned char Ifx_Oe_SyncProtocol_ChecksumPayload;

#define IFX_OE_SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH 254

/** \brief Gneral frame type
 */
typedef struct Ifx_Oe_SyncProtocol_FrameHeader_
{
    /** Header start byte */
    uint8 startByte;
    /** Port that send the header */
    Ifx_Oe_SyncProtocol_Port sender;
    /** Port to which the header is send */
    Ifx_Oe_SyncProtocol_Port receiver;
    /** Payload length in byte */
    uint8 length;
    /** gives information about the content of the packet data */
    Ifx_Oe_SyncProtocol_FrameFlags flags;
    /** Frame payload checksum */
    Ifx_Oe_SyncProtocol_ChecksumPayload checksumPayload;
    /** Frame header checksum */
    Ifx_Oe_SyncProtocol_ChecksumHeader checksumHeader;
}Ifx_Oe_SyncProtocol_FrameHeader;

#define IFX_OE_SYNCPROTOCOL_FRAME_HEADER_SIZE (sizeof(Ifx_Oe_SyncProtocol_FrameHeader))
#define IFX_OE_SYNCPROTOCOL_FIFO_SIZE         (sizeof(Ifx_Oe_SyncProtocol_FrameHeader) * 2 + IFX_OE_SYNCPROTOCOL_FRAME_PAYLOAD_MAX_LENGTH + 2)

/*-------------------------------------------------------------------------*/
/* Ifx_Oe_SyncProtocol: Message                                                   */
/*-------------------------------------------------------------------------*/
/* FIXME allocate RX buffer on demand to avoid fix memory usage when client is not using the RX buffer or only part of it */
#ifndef IFX_OE_SYNCPROTOCOL_MESSAGE_PAYLOAD_MAX_LENGTH
#define IFX_OE_SYNCPROTOCOL_MESSAGE_PAYLOAD_MAX_LENGTH 640
#endif

typedef uint16 Ifx_Oe_SyncProtocol_MessageId;

/**
 * Message ID definition
 * 0x00??  used by Ifx_Oe_SyncProtocol, with ?=any value from 0x0 to 0xF
 * 0x1???  used by OneEye
 * 0x2???  reserved
 * 0x3???  reserved
 * 0xY???  free for use by any other application with ((Y>=4))
 *
 * \note ?=any value from 0x0 to 0xF
 */
#define IFX_OE_SYNCPROTOCOL_MESSAGE_ID_RESERVED_BY_CORE 0x0FFF

/** Message header definition
 * sizeof(Ifx_Oe_SyncProtocol_MessageHeader):8
 *
 * Message format example :
 * struct{
 *     Ifx_Oe_SyncProtocol_MessageHeader header;
 *     uint8 payload[20];
 * }MessageExample;
 */
typedef struct
{
    Ifx_Oe_SyncProtocol_MessageId id; /**< \brief ID of message */
    uint16 dummy;              /**< \brief Reserved, should be 0 & keep alignement on 32 bit */
    uint32 length;             /**< \brief Message length, including header  */
}Ifx_Oe_SyncProtocol_MessageHeader;

#define IFX_OE_SYNCPROTOCOL_MESSAGE_HEADER_SIZE (sizeof(Ifx_Oe_SyncProtocol_MessageHeader))

/** Message: Request a specific message
 */
typedef struct
{
    Ifx_Oe_SyncProtocol_MessageId id;                /**< \brief ID of the requested message */
}Ifx_Oe_SyncProtocol_MessageRequest;

/** Message: Protocol information
 */
typedef struct
{
    uint32 password;                    /**< \brief Password identifying the protocol */
    uint8 version;                      /**< \brief Protocol version */
}Ifx_Oe_SyncProtocol_MessageProtocolInfo;

/*-------------------------------------------------------------------------*/
/* Ifx_Oe_SyncProtocol: Driver                                                    */
/*-------------------------------------------------------------------------*/
typedef struct _Ifx_Oe_SyncProtocol Ifx_Oe_SyncProtocol;

/** Message data
 *
 * @note size must be multiple of 32 bit to enable aligment when stored in the buffer
 */
typedef  struct
{
    /** Send deadline after which the buffered message is discarded */
    Ifx_Oe_SyncProtocol_Time deadline;
    Ifx_Oe_SyncProtocol_MessageId id;
    struct
    {
        uint16 valid : 1;   /**< Set to 1 when the message is valid and ready for send */
        uint16 reserved : 15;
    };
    uint32 dataLength;
    uint8* messagePayload;        /**< Pointer to the message payload. If dataLength is 0, pointer is null */
}Ifx_Oe_SyncProtocol_Message;

typedef struct
{
    /** Pointer to the protocol */
    Ifx_Oe_SyncProtocol* protocol;
    /** Client local port */
    Ifx_Oe_SyncProtocol_Port localPort;
    /** Client remote port */
    Ifx_Oe_SyncProtocol_Port remotePort;

    struct
    {
        /** Indicate if the last message could not be send  */
        boolean messageSendError;
        /** Message header to be send. Only valid is currentMessage.valid is set */
        Ifx_Oe_SyncProtocol_MessageHeader messageHeader;
        /** Index of the next message data byte (header + payload) to be send. Only valid is currentMessage.valid is set  */
        uint32 messageByteIndex;
        /** Number of dropped messages, due to either message timer out or send buffer full */
        uint32 messageDropCounter;
        /** Buffer the message to be send. Can not be null */
        Ifx_Oe_SyncProtocol_Fifo* buffer;
        /** Current message beeing send. Null if no message beeing send */
        Ifx_Oe_SyncProtocol_Message* currentMessage;
    }send;
    struct
    {
        /** Indicate if the received message data is valid */
        boolean messageValid;
        /** Buffer for the message header currently beeing received. Only valid is messageValid is set */
        Ifx_Oe_SyncProtocol_MessageHeader messageHeader;
        /** Buffer for the message payload currently beeing received. Only valid is messageValid is set */
        uint8* messagePayload;
        /** Size of the messagePayload buffer */
        uint32 messagePayloadBufferSize;
        /** Index of the next message data byte to be received. Only valid is messageValid is set  */
        uint32 messageByteIndex;
    }receive;
}Ifx_Oe_SyncProtocol_Client;

typedef enum
{
    Ifx_Oe_SyncProtocol_SendState_readyForSend,
    Ifx_Oe_SyncProtocol_SendState_prepareFrame,
    Ifx_Oe_SyncProtocol_SendState_sendingHeader,
    Ifx_Oe_SyncProtocol_SendState_waitingForHeaderAck,
    Ifx_Oe_SyncProtocol_SendState_sendingPayloadStartByte,
    Ifx_Oe_SyncProtocol_SendState_sendingPayload,
    Ifx_Oe_SyncProtocol_SendState_waitingForPayloadAck,
}Ifx_Oe_SyncProtocol_SendState;

typedef enum
{
    Ifx_Oe_SyncProtocol_ReceiveState_waitingForHeader,
    Ifx_Oe_SyncProtocol_ReceiveState_waitingForPayload,
    Ifx_Oe_SyncProtocol_ReceiveState_readingPayload
}Ifx_Oe_SyncProtocol_ReceiveState;

/** Max lenght of the message that the core can receive */
#define IFX_OE_SYNCPROTOCOL_CORE_MESSAGE_PAYLOAD_MAX_LENGTH (32)

struct _Ifx_Oe_SyncProtocol
{
    Ifx_Oe_SyncProtocol_DPipe* stream;
    Ifx_Oe_SyncProtocol_DPipeStdIf* streamStdif;
    boolean streamOwner;

    /**
     * @brief Protocol synchronized for read, the last received header was valid
     */
    boolean synchronized;

    /** Next frame index to be send. valid frame index are from 1 to IFX_OE_SYNCPROTOCOL_FRAME_MAX_INDEX */
    uint8 frameIndex;

    struct
    {
        uint32 invalidAckFrameIndex;
        uint32 invalidAckStatus;
        uint32 invalidFrameIndex;
        /** The header received has incorrect checksum */
        uint32 invalidHeader;
        uint32 pendingAckOverflow;
        uint32 portClosed;
        uint32 portBusy;
        uint32 invalidStartByte;
        uint32 payloadError;
        uint32 receiveTimeout;
        uint32 sendTimeout;
    } status;

    struct
    {
        /** Current send state */
        Ifx_Oe_SyncProtocol_SendState state;

        /** Buffer for the header currently beeing send. Only valid in states Ifx_Oe_SyncProtocol_SendState_sendingHeader, Ifx_Oe_SyncProtocol_SendState_waitingForHeaderAck, Ifx_Oe_SyncProtocol_SendState_sendingPayloadStartByte, Ifx_Oe_SyncProtocol_SendState_sendingPayload, Ifx_Oe_SyncProtocol_SendState_waitingForPayloadAck */
        Ifx_Oe_SyncProtocol_FrameHeader header;
        /** Index of the next header data byte to be send. Only valid in states Ifx_Oe_SyncProtocol_SendState_sendingHeader, Ifx_Oe_SyncProtocol_SendState_waitingForHeaderAck, Ifx_Oe_SyncProtocol_SendState_sendingPayloadStartByte, Ifx_Oe_SyncProtocol_SendState_sendingPayload, Ifx_Oe_SyncProtocol_SendState_waitingForPayloadAck  */
        uint8 frameHeaderByteIndex;
        /** Indicates if the header ACK have been received, or none is required. Only valid in states Ifx_Oe_SyncProtocol_SendState_sendingHeader, Ifx_Oe_SyncProtocol_SendState_waitingForHeaderAck, Ifx_Oe_SyncProtocol_SendState_sendingPayloadStartByte, Ifx_Oe_SyncProtocol_SendState_sendingPayload, Ifx_Oe_SyncProtocol_SendState_waitingForPayloadAck */
        uint8 headerAckReceived;
        /** Index of the next payload data byte to be send. Only valid in states Ifx_Oe_SyncProtocol_SendState_sendingHeader, Ifx_Oe_SyncProtocol_SendState_waitingForHeaderAck, Ifx_Oe_SyncProtocol_SendState_sendingPayloadStartByte, Ifx_Oe_SyncProtocol_SendState_sendingPayload, Ifx_Oe_SyncProtocol_SendState_waitingForPayloadAck  */
        uint8 framePayloadByteIndex;
        /** Indicates if the payload ACK have been received, or none is required. Only valid in states Ifx_Oe_SyncProtocol_SendState_sendingHeader, Ifx_Oe_SyncProtocol_SendState_waitingForHeaderAck, Ifx_Oe_SyncProtocol_SendState_sendingPayloadStartByte, Ifx_Oe_SyncProtocol_SendState_sendingPayload, Ifx_Oe_SyncProtocol_SendState_waitingForPayloadAck */
        uint8 payloadAckReceived;
        /** Client who's message is currently beeing send */
        Ifx_Oe_SyncProtocol_Client* currentClient;
        /** Pending ACK status to be send. See  IFX_OE_SYNCPROTOCOL_FRAME_PACKET_TYPE_ACK_* */
        uint8 pendingAckStatus;
        /** Pending ACK frame index to be send */
        uint8 pendingAckFrameIndex;
        /** Indicate if the send ack header data is valid */
        boolean ackHeaderValid;
        /** Buffer for the ACK header. Only valid if ackHeaderValid is set */
        Ifx_Oe_SyncProtocol_FrameHeader ackHeader;
        /** Index of the next ack header data byte to be send. Only valid if ackHeaderValid is set   */
        uint8 ackHeaderByteIndex;
        /** Send deadline after which the communication is reset if send is still pending */
        Ifx_Oe_SyncProtocol_Time deadline;
    } send;

    struct
    {
        /** Current receive state */
        Ifx_Oe_SyncProtocol_ReceiveState state;
        /** Buffer for the header currently beeing received */
        Ifx_Oe_SyncProtocol_FrameHeader header;

        /** Buffer for the header currently received. Only valid in state Ifx_Oe_SyncProtocol_ReceiveState_waitingForPayload and Ifx_Oe_SyncProtocol_ReceiveState_readingPayload */
        Ifx_Oe_SyncProtocol_FrameHeader payloadHeader;
        /** Index of the next header data byte to be received. Only valid in state Ifx_Oe_SyncProtocol_ReceiveState_waitingForPayload and Ifx_Oe_SyncProtocol_ReceiveState_readingPayload */
        uint8 frameHeaderByteIndex;
        /** Index of the next payload data byte to be received. Only valid in state Ifx_Oe_SyncProtocol_ReceiveState_waitingForPayload and Ifx_Oe_SyncProtocol_ReceiveState_readingPayload */
        uint8 framePayloadByteIndex;
        /** Last received valid frame index */
        uint8 lastValidFrameIndex;
        /** Receive deadline after which the communication is reset if receive is still pending */
        Ifx_Oe_SyncProtocol_Time deadline;
    } receive;

    /** Frame timeout used for frame send and receive  */
    Ifx_Oe_SyncProtocol_Time timeout;

    /** List of client pointers */
    Ifx_Oe_SyncProtocol_Client* clients[IFX_OE_SYNCPROTOCOL_PORT_MAX + 1];
    /** Core client data */
    Ifx_Oe_SyncProtocol_Client core;
    /** Use to enable / disable core action */
    boolean coreLock;

    /** Set to TRUE when an ACK header is received between the frame header and the frame payload */
    boolean waitingForPayload;

    /** Private memory pool for message data */
    Ifx_Oe_Malloc_Pool* memoryPool;
};

/**
 * @brief Initialize the protocol
 * @param protocol Protocol to be initialized
 * @param timeout Timeout per byte in ms
 * @param streamStdif If NULL, the streamStdif DPipe will be created by this API, else this streamStdif DPipe is used
 */
void Ifx_Oe_SyncProtocol_init(Ifx_Oe_SyncProtocol* protocol, sint32 timeout, Ifx_Oe_SyncProtocol_DPipeStdIf* streamStdif);

/**
 * @brief Return the RX and TX fifo size.
 * If the FIFOs are not created by the Ifx_Oe_SyncProtocol, the size returned by this API must be used to initialize RX and TX FIFO
 */
Ifx_Oe_SyncProtocol_FifoSize Ifx_Oe_SyncProtocol_getFifoSize(void);

/**
 * @brief De-initialize the protocol
 * @param protocol Protocol to be de-initialized
 */
void Ifx_Oe_SyncProtocol_deinit(Ifx_Oe_SyncProtocol* protocol);

/**
 * @brief Initialize and add a new client
 * @param protocol Protocol to which the client should be added
 * @param client Client to be added
 * @param port Client local port. Port \ref IFX_OE_SYNCPROTOCOL_PORT_CORE is reserved by the \ref Ifx_Oe_SyncProtocol
 * @param port Client remote port. Port \ref IFX_OE_SYNCPROTOCOL_PORT_CORE is reserved by the \ref Ifx_Oe_SyncProtocol
 * @param receiveMessagePayloadSize Size of the receive buffer. The buffer will be allocated on the heap
 * @param transmitBufferLength number of message that can be buffered for transmission. The buffer will be allocated on the heap. Must be >= 1
 * @return Return TRUE on success else FALSE. FALSE is returned if the client already exists and client pointer differs
 *
 */
boolean Ifx_Oe_SyncProtocol_addClient(Ifx_Oe_SyncProtocol* protocol, Ifx_Oe_SyncProtocol_Client* client, Ifx_Oe_SyncProtocol_Port localPort, Ifx_Oe_SyncProtocol_Port remotePort, uint32 receiveMessagePayloadSize, Ifx_Oe_SyncProtocol_FifoSize transmitBufferLength);

/**
 * @brief Remove a client from the protocol handling
 * @param client Client to be removed
 * @return Return true on success else false
 *
 * @note The client shall not be sending when this API is called. @see Ifx_Oe_SyncProtocol_isSendBusy
 */
boolean Ifx_Oe_SyncProtocol_removeClient(Ifx_Oe_SyncProtocol_Client* client);

/**
 * @brief Allocate the message send buffer and set the message id and length
 * @param client Protocol client
 * @param id Message ID
 * @param payloadLength Message payload length
 * @return Return a pointer to the message buffer or null on error
 */
Ifx_Oe_SyncProtocol_Message* Ifx_Oe_SyncProtocol_setSendMessageBuffer(Ifx_Oe_SyncProtocol_Client* client, Ifx_Oe_SyncProtocol_MessageId id, uint32 payloadLength);

/**
 * @brief Update the payload length previously set by Ifx_Oe_SyncProtocol_setSendMessageBuffer()
 * @param message Pointer to the message buffer
 * @param payloadLength Message payload length
 * @return Returns true on success else false
 *
 * @note This API can be called on the message as long as Ifx_Oe_SyncProtocol_sendMessage() hasn't been called
 */
boolean Ifx_Oe_SyncProtocol_updatePayloadLength(Ifx_Oe_SyncProtocol_Message* message, uint32 payloadLength);

/**
 * @brief Send a message requested with Ifx_Oe_SyncProtocol_setSendMessageBuffer to the remote port
 * @param message Message to be send.
 *
 * @note this API does not effectively send the message but mark it as ready to be send.
 */
void Ifx_Oe_SyncProtocol_sendMessage(Ifx_Oe_SyncProtocol_Message* message);

/**
 * @brief Drop a message requested with Ifx_Oe_SyncProtocol_setSendMessageBuffer
 * @param message Message to be dropped.
 *
 */
void Ifx_Oe_SyncProtocol_dropMessage(Ifx_Oe_SyncProtocol_Message* message);

/**
 * @brief Return TRUE if the protocol already sending data for the client
 * @param client Client to get the status from
 * @return Return TRUE if the protocol already sending data for the client
 */
inline boolean Ifx_Oe_SyncProtocol_isSendBusy(Ifx_Oe_SyncProtocol_Client* client)
{ return client->send.currentMessage != IFX_OE_SYNCPROTOCOL_NULL; }

/**
 * @brief Return TRUE if a message is available for read by the client
 * @param client Client to get the message from
 * @return Return TRUE if a message is avaiable for read
 */
inline boolean Ifx_Oe_SyncProtocol_isMessageAvailable(Ifx_Oe_SyncProtocol_Client* client)
{ return client->receive.messageValid; }

/**
 * @brief Return a pointer on the last read message with the message header data
 * @param client Protocol client
 * @param payloadLength Size of the payload in byte
 * @param id Received message ID
 * @param messagePayload Pointer to the payload
 * @return Return a pointer on the message payload last read message or NULL if none
 */
boolean Ifx_Oe_SyncProtocol_getReadMessageBuffer(Ifx_Oe_SyncProtocol_Client* client, Ifx_Oe_SyncProtocol_MessageId* id, uint8** messagePayload, uint32* payloadLength);

/**
 * @brief Release the read message buffer
 * @param client Client to ge the status from
 * @return Return TRUE if the protocol already sending data for the client
 */
void Ifx_Oe_SyncProtocol_releaseReadMessageBuffer(Ifx_Oe_SyncProtocol_Client* client);

/**
 * @brief Execute the protocol
 * @param protocol Protocol
 */
void Ifx_Oe_SyncProtocol_execute(Ifx_Oe_SyncProtocol* protocol);

/**
 * @brief Execute the protocol
 * @param protocol Protocol
 * @param timeout Send / receive timeout in ms
 */
inline void Ifx_Oe_SyncProtocol_setTimeout(Ifx_Oe_SyncProtocol* protocol, uint32 timeout)
{
#if IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_QT
    protocol->timeout = timeout;
#elif IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_AURIX
    protocol->timeout = Ifx_Oe_Time_getTickForMilliseconds(timeout);
#endif
}


/**
 * @return Return the send / receive timeout in ms
 */
inline sint64 Ifx_Oe_SyncProtocol_getTimeout(Ifx_Oe_SyncProtocol* protocol)
{
#if IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_QT
    return protocol->timeout;
#elif IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_AURIX
    return protocol->timeout / Ifx_Oe_Time_getTickForMilliseconds(1);
#endif
}


/**
 * @return Returns a pointer on the stream DPipe
 */
inline Ifx_Oe_SyncProtocol_DPipeStdIf* Ifx_Oe_SyncProtocol_getStreamDPipeStdif(Ifx_Oe_SyncProtocol* protocol)
{ return protocol->streamStdif; }

boolean Ifx_Oe_SyncProtocol_printInfo(Ifx_Oe_SyncProtocol* protocol, char* buffer, size_t maxBufferSize);

/*-------------------------------------------------------------------------*/
/* Ifx_Oe_SyncProtocol: Custom message definition                                        */
/*-------------------------------------------------------------------------*/
/* Note: When defining a message, the following must be cared about
 * - __attribute__((__packed__)) should be use to ensure compatibility between compilers. Packed is valid for GNU compilers
 * - Member of struct must be aligned so that no alignment error are triggered by the CPU
 *   - uint8, sint8, char, data aligned on 8 bit
 *   - uint16, sint16, data aligned on 16 bit
 *   - uint32, sint32, float32, data aligned on 16 bit
 */

#define IFX_OE_SYNCPROTOCOL_MESSAGE_ID_RAWDATA   (0x1000)    /**< \see Ifx_Oe_SyncProtocol_MessageRawData */
#define IFX_OE_SYNCPROTOCOL_MESSAGE_ID_RAWBUFFER (0x1001)    /**< \see Ifx_Oe_SyncProtocol_MessageRawBuffer */

typedef enum
{
    Ifx_Oe_SyncProtocol_MessageRawData_Type_uint8    = 0x0,
    Ifx_Oe_SyncProtocol_MessageRawData_Type_sint8    = 0x1,
    Ifx_Oe_SyncProtocol_MessageRawData_Type_uint16   = 0x2,
    Ifx_Oe_SyncProtocol_MessageRawData_Type_sint16   = 0x3,
    Ifx_Oe_SyncProtocol_MessageRawData_Type_uint32   = 0x4,
    Ifx_Oe_SyncProtocol_MessageRawData_Type_sint32   = 0x5,
    Ifx_Oe_SyncProtocol_MessageRawData_Type_uint64   = 0x6,
    Ifx_Oe_SyncProtocol_MessageRawData_Type_sint64   = 0x7,
    Ifx_Oe_SyncProtocol_MessageRawData_Type_float32  = 0x8,
    Ifx_Oe_SyncProtocol_MessageRawData_Type_char     = 0x9,
    Ifx_Oe_SyncProtocol_MessageRawData_Type_bit      = 0xA,
    Ifx_Oe_SyncProtocol_MessageRawData_Type_bitfield = 0xB,
    Ifx_Oe_SyncProtocol_MessageRawData_Type_register = 0xC,
}Ifx_Oe_SyncProtocol_MessageRawData_Type;

#if defined(__HIGHTEC__) || (IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_QT)
typedef struct __attribute__ ((__packed__))
#elif defined(__TASKING__)
typedef struct
#else
typedef struct
#endif
{
    union
    {
        uint8 asUint8;
        sint8 asSint8;
        uint16 asUint16;
        sint16 asSint16;
        uint32 asUint32;
        sint32 asSint32;
        uint64 asUint64;
        sint64 asSint64;
        float32 asFloat32;
    } data;
    uint8 type;
} Ifx_Oe_SyncProtocol_MessageRawData;

#if defined(__HIGHTEC__) || (IFX_OE_SYNCPROTOCOL_VARIANT == IFX_OE_SYNCPROTOCOL_VARIANT_QT)
typedef struct __attribute__ ((__packed__))
#elif defined(__TASKING__)
typedef struct
#else
typedef struct
#endif
{
    char payload[IFX_OE_SYNCPROTOCOL_MESSAGE_PAYLOAD_MAX_LENGTH];
} Ifx_Oe_SyncProtocol_MessageRawBuffer;

#ifdef __cplusplus
}
#endif

#endif
