/**********************************************************************************************************************
 * \file DataMultiplexer.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "DataMultiplexer.h"
#include "SignalGenerator.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* Number of milliseconds to wait between transmit */
#define WAIT_TIME 100

/* Local port for the BB protocol multiplexer / de-multiplexer channel */
#define BB_LOCAL_PORT_DEMUX (1)

/* Remote port for the BB protocol multiplexer / de-multiplexer channel */
#define BB_REMOTE_PORT_DEMUX (1)

/*********************************************************************************************************************/
/*------------------------------------------------------Typedef------------------------------------------------------*/
/*********************************************************************************************************************/
/* Message ID used for the DataStreaming_Data_0 data */
#define SYNCPROTOCOL_MESSAGE_ID_DATASTREAMING_DATA_0 (0x4000)
#if defined(__HIGHTEC__)
typedef struct __attribute__ ((__packed__))
#elif defined(__TASKING__)
typedef struct
#else
typedef struct
#endif
{
    float32 signalA;    /* signalA value        */
    sint32 signalB;     /* signalB value        */
} DataStreaming_Data_0;

/* Message ID used for the DataStreaming_Data_1 data */
#define SYNCPROTOCOL_MESSAGE_ID_DATASTREAMING_DATA_1 (0x4001)
#if defined(__HIGHTEC__)
typedef struct __attribute__ ((__packed__))
#elif defined(__TASKING__)
typedef struct
#else
typedef struct
#endif
{
    float32 max;        /* Max command value    */
} DataStreaming_Data_1;

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* Synch protocol data multiplexer object */
Ifx_Oe_SyncProtocol_Client g_dataMultiplexer;

/* Deadline for data multiplexer transmit */
static Ifx_Oe_TickTime g_deadline;

/* Enable (defined) / disable (undefined) the OneEye command */
#define USE_ONEEYE_COMMAND

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

void initDataMultiplexer(Ifx_Oe_SyncProtocol* syncProtocol)
{
    /* Initialize the sync protocol channel assigned to the data multiplexer / multiplexer */
    Ifx_Oe_SyncProtocol_addClient(syncProtocol, &g_dataMultiplexer, BB_LOCAL_PORT_DEMUX, BB_REMOTE_PORT_DEMUX, IFX_OE_SYNCPROTOCOL_MESSAGE_PAYLOAD_MAX_LENGTH, 10);

    /* Initialize deadline to 0 so that the data multiplexer sends on the next call */
    g_deadline = 0;
}


void processDataMultiplexer(void)
{
    /* Check if a message has been received */
    if (Ifx_Oe_SyncProtocol_isMessageAvailable(&g_dataMultiplexer))
    {
        Ifx_Oe_SyncProtocol_MessageId id;
        uint32                        length;
        uint8*                        payloadRx;

        /* Get the message ID, the message length and a pointer to the message payload */
        if (Ifx_Oe_SyncProtocol_getReadMessageBuffer(&g_dataMultiplexer, &id, &payloadRx, &length))
        {
            /* Place holder for incoming messages */
#ifdef USE_ONEEYE_COMMAND

            switch (id)
            {
            case SYNCPROTOCOL_MESSAGE_ID_DATASTREAMING_DATA_1:
            {
                /* Cast the payload to the DataStreaming_Data_1 structure */
                DataStreaming_Data_1* m = (DataStreaming_Data_1*)payloadRx;

                /* Extract the message data */
                g_signalGenerator.input.max = m->max;
            }
            break;
            }

#endif
            /* Release the message */
            Ifx_Oe_SyncProtocol_releaseReadMessageBuffer(&g_dataMultiplexer);
        }
    }

    /* Send message periodically */
    if (Ifx_Oe_Time_isDeadLine(g_deadline))
    {
        g_deadline = Ifx_Oe_Time_add(g_deadline, Ifx_Oe_Time_getTickForMilliseconds(WAIT_TIME));

        /* Request a message for send */
        Ifx_Oe_SyncProtocol_Message* message = Ifx_Oe_SyncProtocol_setSendMessageBuffer(
            &g_dataMultiplexer,
            SYNCPROTOCOL_MESSAGE_ID_DATASTREAMING_DATA_0,
            sizeof(DataStreaming_Data_0));

        if (message != NULL_PTR)
        {
            /* Cast the payload to the DataStreaming_Data_0 structure */
            DataStreaming_Data_0* m = (DataStreaming_Data_0*)message->messagePayload;
            /* Fill the message */
            m->signalA = g_signalGenerator.output.signalA;
            m->signalB = g_signalGenerator.output.signalB;

            /* Send the message */
            Ifx_Oe_SyncProtocol_sendMessage(message);
        }
    }
}
