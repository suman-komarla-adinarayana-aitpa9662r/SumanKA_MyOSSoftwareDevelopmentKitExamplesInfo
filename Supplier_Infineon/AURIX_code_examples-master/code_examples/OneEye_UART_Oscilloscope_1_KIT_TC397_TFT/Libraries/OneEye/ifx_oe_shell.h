/**
 * \file ifx_oe_shell.h
 * \brief Shell functions.
 *
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * This module implements the Shell functions.
 * It parses a command line and call the corresponding command execution.
 * Multiple command list can be used in parallel.
 *
 * Only full command match is accepted.
 *
 * New feature / change:
 * - Prefix can be defined for each command list
 * - Help for a single command is displayed with "help <command>"
 * - help for a command list is displayed with "help <listPrefix>"
 * - command short cut is not allowed
 * - command with identical start option "opt1 opt2" and "opt1 opt3" are accepted, and root to different handlers
 * - Enhanced help info print
 *
 * Help text syntax:
 * - /p indicates a parameter description, can be multi-line, lines must be separated with IFX_OE_ENDL
 * - /s Indicates a syntax help
 * - /= Indicates a help section
 * - /- Indicates a help sub-section
 *
 * Example of help list:
 * \code
 * Ifx_Oe_Shell_Command Ifx_g_Oe_OsciShell_commands[] =
 * {
 *     {IFX_OE_OSCI_SHELL_PREFIX, "     : Oscilloscope functions"
 *          , NULL_PTR, NULL_PTR               },
 *     {"run", "      : run the oscilloscope"IFX_OE_ENDL
 *      "/s run [single|auto|normal]"
 *          , NULL_PTR, &Ifx_Oe_OsciShell_run     },
 *     {"stop", "     : stop oscilloscope"
 *          , NULL_PTR, &Ifx_Oe_OsciShell_stop    },
 *     {"trigger", "  : trigger settings"IFX_OE_ENDL
 *      "/s trigger [force|single|level <value>|raising|falling|source <chNum>|interval <value>]"IFX_OE_ENDL
 *          "/p force: Force the trigger"IFX_OE_ENDL
 *          "/p single: Single the trigger"IFX_OE_ENDL
 *          "/p level <value>: Set trigger level to value"IFX_OE_ENDL
 *          "/p [raising|falling]: Set trigger to raising or falling edges"IFX_OE_ENDL
 *          "/p source <chNum>: Set trigger channel number"IFX_OE_ENDL
 *          "<chNum> can be obtained with 'channel' command"IFX_OE_ENDL
 *          "/p interval <value>: Set sampling interval to value"
 *
 *          , NULL_PTR, &Ifx_Oe_OsciShell_trigger },
 *     {"status", "   : display status"
 *          , NULL_PTR, &Ifx_Oe_OsciShell_status  },
 *     {"channel", "  : channel information"IFX_OE_ENDL
 *          "/s channel: Show the channels information"IFX_OE_ENDL
 *          "/s channel <ch> <sig>: Assign a signal to a channel"
 *          , NULL_PTR, &Ifx_Oe_OsciShell_channel },
 *     {"analyze", "  : signal analysis of a ch"IFX_OE_ENDL
 *      "/s analyze <ch>: analyze the input channel <ch>"
 *          , NULL_PTR, &Ifx_Oe_OsciShell_analyze },
 *     {"simulate", " : simulate a signal"IFX_OE_ENDL
 *      "/s simulate <ch> <op> <wave> <freq> <ampl> <offs> <phase> : Simulate a signal generation"IFX_OE_ENDL
 *             "/p <ch>   : {0 .. Channel count}"IFX_OE_ENDL
 *             "/p <op>   : {add,sub,mul,clr}"IFX_OE_ENDL
 *             "/p <wave> : {sine,square}"IFX_OE_ENDL
 *             "/p <freq> : -INF .. INF"IFX_OE_ENDL
 *             "/p <offs> : -INF .. INF"IFX_OE_ENDL
 *             "/p <ampl> : -INF .. INF"IFX_OE_ENDL
 *             "/p <phase>: 0 .. 360 [degree]"IFX_OE_ENDL
 *         "/s simulate <ch> atan <ych> <xch>: Compute atan(ych/xch) and store in channel <ch>"
 *          , NULL_PTR, &Ifx_Oe_OsciShell_simulate},
 *     {"dump", "     : dump values (all channels)"IFX_OE_ENDL
 *      "/s dump <ch> [hex]"IFX_OE_ENDL
 *          "/p <ch>: Dump the values of the channel <ch>"IFX_OE_ENDL
 *          "/p hex: If hex is specified, values will be in hexadecimal"
 *          , NULL_PTR, &Ifx_Oe_OsciShell_dump    },
 *     IFX_OE_SHELL_COMMAND_LIST_END,
 * };
 * \endcode
 *
 * To enable help command, include the below command in the main command list
 *    {"help",         IFX_OE_SHELL_HELP_DESCRIPTION_TEXT                             , &\<Ifx_Oe_Shell\>, &Ifx_Oe_Shell_showHelp,       },
 *
 *
 */

#ifndef IFX_OE_SHELL_H
#define IFX_OE_SHELL_H
//----------------------------------------------------------------------------------------
#include "ifx_oe_dpipewrapper.h"

//----------------------------------------------------------------------------------------
#define IFX_OE_SHELL_NULL_CHAR '\0'

#ifndef IFX_CFG_OE_SHELL_CMD_HISTORY_SIZE
#define IFX_CFG_OE_SHELL_CMD_HISTORY_SIZE (10)     /**<\brief Number of commands to store in history */
#endif

#ifndef IFX_CFG_OE_SHELL_CMD_LINE_SIZE
#define IFX_CFG_OE_SHELL_CMD_LINE_SIZE (128)       /**<\brief max command line IFX_CFG_OE_SHELL_CMD_LINE_SIZE - 1 */
#endif

#ifndef IFX_CFG_OE_SHELL_COMMAND_LISTS
#define IFX_CFG_OE_SHELL_COMMAND_LISTS (1)         /**<\brief Number of command lists */
#endif

#ifndef IFX_CFG_OE_SHELL_PROMPT
#define IFX_CFG_OE_SHELL_PROMPT "Shell>"              /**<\brief Shell prompt */
#endif

#if !defined(IFX_CFG_OE_SHELL_TIMEOUT)
#define IFX_CFG_OE_SHELL_TIMEOUT (Ifx_Oe_Time_infinite) /**<\brief Default shell Tx timeout */
#endif

#define IFX_OE_SHELL_HELP_DESCRIPTION_TEXT                      \
    "     : Display command list, and command help." IFX_OE_ENDL \
    "/s help: show all commands" IFX_OE_ENDL                     \
    "/s help <command>: show the command details"

/** \brief Marker for end of command list, the end of list is detected by commandLine=NULL */
#define IFX_OE_SHELL_COMMAND_LIST_END { 0, 0, 0, 0 }

/** \brief Marker for end of syntax list */
#define IFX_OE_SHELL_SYNTAX_LIST_END { 0, 0 }

/** \brief Signifies no item in use in command history list */
#define IFX_OE_SHELL_CMD_HISTORY_NO_ITEM (-1)
//----------------------------------------------------------------------------------------
typedef enum
{
    Ifx_Oe_Shell_ExecuteCode_ok                = 0x00000000,    /** \brief Command found and executed without error  */
    Ifx_Oe_Shell_ExecuteCode_cmdError          = 0x00000001,    /** \brief Command found and executed with error  */
    Ifx_Oe_Shell_ExecuteCode_notFound          = -1,    /** \brief Command not */
    Ifx_Oe_Shell_ExecuteCode_okNoHistory       = 0x00010000,        /** \brief Command found and executed without error  */
    Ifx_Oe_Shell_ExecuteCode_cmdErrorNoHistory = 0x00010001,        /** \brief Command found and executed with error  */
}Ifx_Oe_Shell_ExecuteCode;

/** \brief Result code definition used after each executed Shell command */
typedef enum
{
    Ifx_Oe_Shell_ResultCode_unknown   = (128),
    Ifx_Oe_Shell_ResultCode_nok       = (129),
    Ifx_Oe_Shell_ResultCode_undefined = (130),
    Ifx_Oe_Shell_ResultCode_ok        = (255)
} Ifx_Oe_Shell_ResultCode;

/** \brief Definition of a callback function which handles a Shell command */
typedef boolean (* Ifx_Oe_Shell_Call)(pchar args, void* data, IfxStdIf_DPipe* io);

/** \brief Shell command object */
typedef struct
{
    pchar commandLine;
    pchar help;
    void* data;
    Ifx_Oe_Shell_Call call;
} Ifx_Oe_Shell_Command;

/** \brief Command line editing state */
typedef struct
{
    char* cmdStr;                   /**< \brief Pointer to current string containing command line as so far processed                                    */
    Ifx_Oe_SizeT cursor;               /**< \brief Pointer to variable containing position of cursor in so-far-processed command line                       */
    Ifx_Oe_SizeT length;               /**< \brief Pointer to variable containing total length of command line                                              */
    boolean historyAdd;             /**< \brief If TRUE, when Enter is pressed, the current cmdLine should be added to the command history (in parent)   */
    Ifx_Oe_SizeT historyItem;          /**< \brief Item ID in command history list, or IFX_OE_SHELL_CMD_HISTORY_NO_ITEM if not using list (e.g. new command)       */
} Ifx_Oe_Shell_CmdLine;

/** \brief Shell command processing state */
typedef enum
{
    Ifx_Oe_Shell_CmdState_normal,                 /**< \brief Normal - no special sequences being processed */
    Ifx_Oe_Shell_CmdState_escape,                 /**< \brief Escape character has been pressed */
    Ifx_Oe_Shell_CmdState_escapeBracket,         /**< \brief ESC [ pressed */
    Ifx_Oe_Shell_CmdState_escapeBracketNumber   /**< \brief ESC [ (number) pressed */
} Ifx_Oe_Shell_CmdState;

/** \brief Shell protocol configuration */
typedef struct
{
    boolean (* start)(void* protocol, IfxStdIf_DPipe* io);
    void (*execute)(void* protocol);
    void (*onStart)(void* protocol, void* data);
    void* onStartData;
    void* object;
    boolean started;
} Ifx_Oe_Shell_Protocol;

/** \brief Shell control flags */
typedef struct
{
    uint16 showPrompt : 1;
    uint16 enabled : 1;
    uint16 execute : 1; /* If set, Ifx_Oe_Shell_execute() is called within Ifx_Oe_Shell_process(). Default */
    uint16 sendResultCode : 1;
    uint16 echo : 1;
    uint16 echoError : 1;
} Ifx_Oe_Shell_Flags;

/** \brief internal Shell run-time data */
typedef struct
{
    char echo[2];
    char inputbuffer[IFX_CFG_OE_SHELL_CMD_LINE_SIZE + 1];
    char cmdStr[IFX_CFG_OE_SHELL_CMD_LINE_SIZE];
    Ifx_Oe_Shell_CmdState cmdState;
    char escBracketNum;
} Ifx_Oe_Shell_Runtime;

typedef Ifx_Oe_Shell_Command*       Ifx_Oe_Shell_CommandList;
typedef const Ifx_Oe_Shell_Command* Ifx_Oe_Shell_CommandListConst;
/**
 * \brief Shell object definition
 */
typedef struct
{
    IfxStdIf_DPipe* io;             /**< \brief Pointer to IfxStdIf_DPipe object used by the Shell */

    Ifx_Oe_Shell_Flags control;        /**< \brief control flags */

    /** \brief Array of pointers to the history entries */
    char* cmdHistory[IFX_CFG_OE_SHELL_CMD_HISTORY_SIZE];

    /** \brief Current status of command line editing (saves passing many parameters around) */
    Ifx_Oe_Shell_CmdLine cmd;

    Ifx_Oe_Shell_Runtime locals;       /**< \brief Runtime data */

    /** \brief Array of pointers to command list. The pointed location shall be constant
     * during Shell lifetime, e.g. stored in non-volatile memory or as global variable
     *
     * The 1st item in the list is use as a group command prefix if its "call" parameter is NULL pointer, else it is use as other entries.
     * In case "call" is NULL, the corresponding 'data' is ignored, and the 'help' is displayed.
     *
     **/
    Ifx_Oe_Shell_CommandListConst commandList[IFX_CFG_OE_SHELL_COMMAND_LISTS];

    Ifx_Oe_Shell_Protocol protocol;         /**< \brief Protocol handler data */
} Ifx_Oe_Shell;

/**
 * \brief Shell configuration.
 */
typedef struct
{
    IfxStdIf_DPipe* standardIo;                                          /**<\brief Pointer to a IfxStdIf_DPipe object used by the Shell */
    boolean echo;                                                        /**<\brief Specifies whether each command shall be echoed back to user */
    boolean showPrompt;                                                  /**<\brief Specifies whether the IFX_CFG_OE_SHELL_PROMPT shall be displayed after each command */
    boolean sendResultCode;                                              /**<\brief Specifies whether the Ifx_Oe_Shell_ResultCode shall be sent to user */
    Ifx_Oe_Shell_CommandListConst commandList[IFX_CFG_OE_SHELL_COMMAND_LISTS]; /**< \brief Specifies pointer to the command list */
    Ifx_Oe_Shell_Protocol protocol;                                         /**<\brief Configuration for the Ifx_Oe_Shell_Protocol */
    boolean execute;                                                     /**< \brief If set, Ifx_Oe_Shell_execute() is called within Ifx_Oe_Shell_process(). Default */
} Ifx_Oe_Shell_Config;

/**
 * \brief Shell Syntax Description.
 */
typedef struct
{
    pchar syntax;                      /**<\brief syntax */
    pchar description;                 /**<\brief description */
} Ifx_Oe_Shell_Syntax;

//----------------------------------------------------------------------------------------
/** \addtogroup library_srvsw_sysse_comm_shell
 * \{ */

/** \name Basic functionality
 * \{ */

IFX_OE_EXTERN Ifx_Oe_Shell_ExecuteCode Ifx_Oe_Shell_execute(Ifx_Oe_Shell* shell, pchar commandLine);

/** Set the config default parameter
 *
 * \param config Pointer to the configuration structure to be initialized
 */
IFX_OE_EXTERN void Ifx_Oe_Shell_initConfig(Ifx_Oe_Shell_Config* config);

/**
 * \brief Initialize the shell
 * \param shell Pointer to the \ref Ifx_Oe_Shell object
 * \param config Pointer to the configuration structure
 */
IFX_OE_EXTERN boolean Ifx_Oe_Shell_init(Ifx_Oe_Shell* shell, const Ifx_Oe_Shell_Config* config);

/**
 * \brief Deinitialise the shell
 * \param shell Pointer to the \ref Ifx_Oe_Shell object
 */
IFX_OE_EXTERN void Ifx_Oe_Shell_deinit(Ifx_Oe_Shell* shell);

/**
 * \brief Clear the receive buffer and enable the shell
 * \param shell Pointer to the \ref Ifx_Oe_Shell object
 */
IFX_OE_EXTERN void Ifx_Oe_Shell_enable(Ifx_Oe_Shell* shell);

/**
 * \brief Disable the shell
 * \param shell Pointer to the \ref Ifx_Oe_Shell object
 */
IFX_OE_EXTERN void Ifx_Oe_Shell_disable(Ifx_Oe_Shell* shell);

typedef enum
{
    Ifx_Oe_Shell_SpecialKey_null  = 0,
    Ifx_Oe_Shell_SpecialKey_cr    = '\r',
    Ifx_Oe_Shell_SpecialKey_ctrlC = '\x03',
    Ifx_Oe_Shell_SpecialKey_ok    = 0x10000         /**< Command has been executed successfully */
}Ifx_Oe_Shell_SpecialKey;

#define IFX_OE_SHELL_KEY_NULL   (Ifx_Oe_Shell_SpecialKey_null)
#define IFX_OE_SHELL_KEY_CR     (Ifx_Oe_Shell_SpecialKey_cr)
#define IFX_OE_SHELL_KEY_CTRL_C (Ifx_Oe_Shell_SpecialKey_ctrlC)
#define IFX_OE_SHELL_KEY_OK     (Ifx_Oe_Shell_SpecialKey_ok) /* Command has been executed successfully */

/**
 * \brief Process the shell.
 *
 * This function shall be called within a loop or periodic timer to guarantee the correct
 * processing of the incoming/received data.
 *
 * \param shell Pointer to the \ref Ifx_Oe_Shell object
 * \retval IFX_OE_SHELL_CARRIAGE_RETURN if the ENTER is pressed (\n or \r) and command line not empty. Command can be read from the command history entry 0
 * \retval IFX_OE_SHELL_CTRL_C if CTRL + C is pressed
 * \retval else IFX_OE_SHELL_NULL
 */
IFX_OE_EXTERN Ifx_Oe_Shell_SpecialKey Ifx_Oe_Shell_process(Ifx_Oe_Shell* shell);

/** Prefil the shell command line and echo to the console if configured
 * \param text Text to be prefilled in the command line
 */
IFX_OE_EXTERN void Ifx_Oe_Shell_prefill(Ifx_Oe_Shell* shell, const char* text);

/** \} */
//----------------------------------------------------------------------------------------
/** \name Parsing functions
 * \{ */

/**
 * \brief Within the context of Shell.call, skip the whitespaces of the args string.
 * \param args Pointer to the original string
 * \return Pointer to the string after skipping the whitespaces
 */
IFX_OE_EXTERN pchar Ifx_Oe_Shell_skipWhitespace(pchar args);

/**
 * \brief Match string pointed by the *argsPtr with a given token
 * \param argsPtr Pointer to the argument null-terminated string
 * \param token Pointer to the token string to match
 * \retval TRUE if the given token match with the string pointed by argsPtr
 */
IFX_OE_EXTERN boolean Ifx_Oe_Shell_matchToken(pchar* argsPtr, pchar token);

IFX_OE_EXTERN boolean Ifx_Oe_Shell_matchCommand(pchar* argsPtr, pchar* match);

/**
 * \brief Parse a token
 * Return the next token in tokenBuffer and move the argsPtr pointer after this token
 * \param argsPtr Pointer to the argument null-terminated string
 * \param tokenBuffer Pointer to the value storage
 * \param bufferLength Maximum parsing length
 */
IFX_OE_EXTERN boolean Ifx_Oe_Shell_parseToken(pchar* argsPtr, char* tokenBuffer, int bufferLength);

/**
 * \brief Parse an address
 * \param argsPtr Pointer to the argument null-terminated string
 * \param address Pointer to the value storage
 */
IFX_OE_EXTERN boolean Ifx_Oe_Shell_parseAddress(pchar* argsPtr, void** address);

/**
 * \brief Parse a signed 32-bit integer value
 * \param argsPtr Pointer to the argument null-terminated string
 * \param value Pointer to the value storage
 */
IFX_OE_EXTERN boolean Ifx_Oe_Shell_parseSInt32(pchar* argsPtr, sint32* value);

/**
 * \brief Parse an unsigned 32-bit integer value
 * \param argsPtr Pointer to the argument null-terminated string
 * \param value Pointer to the value storage
 * \param hex if TRUE, hex parsing will be done, else decimal parsing
 */
IFX_OE_EXTERN boolean Ifx_Oe_Shell_parseUInt32(pchar* argsPtr, uint32* value, boolean hex);

/**
 * \brief Parse a signed 64-bit integer value
 * \param argsPtr Pointer to the argument null-terminated string
 * \param value Pointer to the value storage
 */
IFX_OE_EXTERN boolean Ifx_Oe_Shell_parseSInt64(pchar* argsPtr, sint64* value);

/**
 * \brief Parse an unsigned 64-bit integer value
 * \param argsPtr Pointer to the argument null-terminated string
 * \param value Pointer to the value storage
 * \param hex if TRUE, hex parsing will be done, else decimal parsing
 */
IFX_OE_EXTERN boolean Ifx_Oe_Shell_parseUInt64(pchar* argsPtr, uint64* value, boolean hex);

/**
 * \brief Parse a 64-bit (double precision) floating-point value
 * \param argsPtr Pointer to the argument null-terminated string
 * \param value Pointer to the value storage
 */
IFX_OE_EXTERN boolean Ifx_Oe_Shell_parseFloat64(pchar* argsPtr, float64* value);

/**
 * \brief Parse a 32-bit (single precision) floating-point value
 * \param argsPtr Pointer to the argument null-terminated string
 * \param value Pointer to the value storage
 */
IFX_OE_EXTERN boolean Ifx_Oe_Shell_parseFloat32(pchar* argsPtr, float32* value);

/** \} */
//----------------------------------------------------------------------------------------
/** \name Command list functions
 * \{ */

/**
 * \brief Find command in command List
 * \param commandList Pointer to the first entry of an array of \ref Ifx_Oe_Shell_Command
 * \param commandLine Pointer to null-terminated string containings the command to search.
 * \param args Pointer to the argument null-terminated string
 * \param match Return the number of arguments that matches
 */
IFX_OE_EXTERN const Ifx_Oe_Shell_Command* Ifx_Oe_Shell_commandFind(Ifx_Oe_Shell_CommandListConst commandList, pchar commandLine, pchar* args, uint32* match);

/**
 * \brief Implementation of \ref Ifx_Oe_Shell_Call. Show the help menu from single command list.
 * \param commandList Pointer to an array of Ifx_Oe_Shell_Command
 * \param io Pointer to the IfxStdIf_DPipe object
 * \param briefOnly if TRUE, show only the brief description, else show the full description
 * \param singleCommand If TRUE, only show the 1st command pointed by commandList, else show the full list
 */
IFX_OE_EXTERN boolean Ifx_Oe_Shell_showHelpSingle(Ifx_Oe_Shell_CommandListConst commandList, IfxStdIf_DPipe* io, boolean briefOnly, boolean singleCommand);

/**
 * \brief Implementation of \ref Ifx_Oe_Shell_Call. Show the help menu and list of commands.
 * \param args The argument null-terminated string
 * \param shellPtr Pointer to a Shell object
 * \param io Pointer to \ref IfxStdIf_DPipe object
 */
IFX_OE_EXTERN boolean Ifx_Oe_Shell_showHelp(pchar args, void* shellPtr, IfxStdIf_DPipe* io);

/**
 * \brief Implementation of \ref Ifx_Oe_Shell_Call. print the syntax.
 * \param syntaxList Pointer to syntax list
 * \param io Pointer to \ref IfxStdIf_DPipe object
 */
IFX_OE_EXTERN void Ifx_Oe_Shell_printSyntax(const Ifx_Oe_Shell_Syntax* syntaxList, IfxStdIf_DPipe* io);

/** \} */
//----------------------------------------------------------------------------------------
/** \name Sub protocol functions
 * \{ */

/**
 * \brief Implementation of \ref Ifx_Oe_Shell_Call. Start the Shell protocol.
 * \param args The argument null-terminated string
 * \param data Pointer to \ref Ifx_Oe_Shell object
 * \param io Pointer to \ref IfxStdIf_DPipe object
 */
IFX_OE_EXTERN boolean Ifx_Oe_Shell_protocolStart(pchar args, void* data, IfxStdIf_DPipe* io);

/**
 * \brief Implementation of \ref Ifx_Oe_Shell_Call. Start the Shell protocol.
 * \param args The argument null-terminated string
 * \param data Pointer to \ref Ifx_Oe_Shell object
 * \param io Pointer to \ref IfxStdIf_DPipe object
 */
IFX_OE_EXTERN boolean Ifx_Oe_Shell_bbProtocolStart(pchar args, void* data, IfxStdIf_DPipe* io);

/** \} */
//----------------------------------------------------------------------------------------
/** \} */

#endif
