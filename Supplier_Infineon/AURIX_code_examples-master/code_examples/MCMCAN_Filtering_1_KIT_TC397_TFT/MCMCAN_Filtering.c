/********************************************************************************************************************
 * \file MCMCAN_Filtering.c
 * \copyright Copyright (C) Infineon Technologies AG 2020
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "MCMCAN_Filtering.h"

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
mcmcanType                  g_mcmcan;
canCommunicationStatusType  g_status = CanCommunicationStatus_Success;
IfxPort_Pin_Config          g_led1;
static volatile uint8       g_currentFilterUseCase;
volatile uint8              g_isrRxCount = 0;       /* Declared as volatile in order not to be removed by compiler  */
const uint8                 g_dlcLookUpTableWord[] = { 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 4, 5, 6, 8, 12, 16 };
const uint8                 g_dataFieldSizeLookUpTable[] = { 8, 12, 16, 20, 24, 32, 48, 64 };
const useCaseConfigType     g_useCaseConf[NUMBER_OF_CAN_MESSAGES] =
{
   { 0x014,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_standard,      IfxCan_DataLengthCode_8,  CanFilterAcceptance_Accept, CanStoreInDestinationType_RxFifo0 },
   { 0x015,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_standard,      IfxCan_DataLengthCode_8,  CanFilterAcceptance_Accept, CanStoreInDestinationType_RxFifo0 },
   { 0x016,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_fdLong,        IfxCan_DataLengthCode_32, CanFilterAcceptance_Accept, CanStoreInDestinationType_RxFifo0 },
   { 0x017,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_fdLongAndFast, IfxCan_DataLengthCode_64, CanFilterAcceptance_Reject, CanStoreInDestinationType_notApplicable },
   { 0x018,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_fdLongAndFast, IfxCan_DataLengthCode_12, CanFilterAcceptance_Reject, CanStoreInDestinationType_notApplicable },
   { 0x019,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_fdLong,        IfxCan_DataLengthCode_16, CanFilterAcceptance_Reject, CanStoreInDestinationType_notApplicable },
   { 0x01A,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_fdLong,        IfxCan_DataLengthCode_32, CanFilterAcceptance_Accept, CanStoreInDestinationType_RxFifo0 },
   { 0x184,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_standard,      IfxCan_DataLengthCode_4,  CanFilterAcceptance_Accept, CanStoreInDestinationType_RxFifo1 },
   { 0x187,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_standard,      IfxCan_DataLengthCode_8,  CanFilterAcceptance_Accept, CanStoreInDestinationType_RxFifo1 },
   { 0x189,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_standard,      IfxCan_DataLengthCode_8,  CanFilterAcceptance_Accept, CanStoreInDestinationType_RxFifo0 },
   { 0x200,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_standard,      IfxCan_DataLengthCode_8,  CanFilterAcceptance_Accept, CanStoreInDestinationType_RxFifo0 },
   { 0x201,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_standard,      IfxCan_DataLengthCode_8,  CanFilterAcceptance_Reject, CanStoreInDestinationType_notApplicable },
   { 0x220,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_standard,      IfxCan_DataLengthCode_8,  CanFilterAcceptance_Accept, CanStoreInDestinationType_RxFifo0 },
   { 0x221,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_fdLong,        IfxCan_DataLengthCode_8,  CanFilterAcceptance_Reject, CanStoreInDestinationType_notApplicable },
   { 0x240,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_standard,      IfxCan_DataLengthCode_4,  CanFilterAcceptance_Accept, CanStoreInDestinationType_RxFifo0 },
   { 0x241,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_fdLongAndFast, IfxCan_DataLengthCode_64, CanFilterAcceptance_Reject, CanStoreInDestinationType_notApplicable },
   { 0x260,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_fdLongAndFast, IfxCan_DataLengthCode_12, CanFilterAcceptance_Accept, CanStoreInDestinationType_RxFifo0 },
   { 0x261,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_standard,      IfxCan_DataLengthCode_8,  CanFilterAcceptance_Reject, CanStoreInDestinationType_notApplicable },
   { 0x325,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_standard,      IfxCan_DataLengthCode_4,  CanFilterAcceptance_Accept, CanStoreInDestinationType_RxBuffer },
   { 0x326,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_fdLongAndFast, IfxCan_DataLengthCode_32, CanFilterAcceptance_Accept, CanStoreInDestinationType_RxBuffer },
   { 0x327,      IfxCan_MessageIdLength_standard, IfxCan_FrameMode_standard,      IfxCan_DataLengthCode_8,  CanFilterAcceptance_Accept, CanStoreInDestinationType_RxFifo1 },
   { 0x12222222, IfxCan_MessageIdLength_extended, IfxCan_FrameMode_standard,      IfxCan_DataLengthCode_8,  CanFilterAcceptance_Accept, CanStoreInDestinationType_RxBuffer },
   { 0x19999999, IfxCan_MessageIdLength_extended, IfxCan_FrameMode_standard,      IfxCan_DataLengthCode_8,  CanFilterAcceptance_Accept, CanStoreInDestinationType_RxFifo1 },
   { 0x1FFABCDE, IfxCan_MessageIdLength_extended, IfxCan_FrameMode_fdLongAndFast, IfxCan_DataLengthCode_32, CanFilterAcceptance_Accept, CanStoreInDestinationType_RxFifo0 },
   { 0x16666666, IfxCan_MessageIdLength_extended, IfxCan_FrameMode_standard,      IfxCan_DataLengthCode_8,  CanFilterAcceptance_Accept, CanStoreInDestinationType_RxFifo1 }
};

/* ====================================================================================================================
 * CAN filter configuration:
 * ====================================================================================================================
 * Each filter element is defined based on the following configuration options:
 *  - Filter element number
 *  - Standard/Extended filter element configuration (StdMsgk_S0(k=0-127).SFEC / ExtMsgk_F0(k=0-63).EFEC)
 *  - Standard/Extended filter type (StdMsgk_S0(k=0-127).SFT / ExtMsgk_F1(k=0-63).EFT)
 *  - Standard/Extended filter ID 1 (StdMsgk_S0(k=0-127).SFID1 / ExtMsgk_F0(k=0-63).EFID1)
 *  - Standard/Extended filter ID 2 (StdMsgk_S0(k=0-127).SFID2 / ExtMsgk_F1(k=0-63).EFID2)
 *  - Rx buffer offset to the Rx buffer start address
 * ====================================================================================================================
 * For this example the following standard ID filter configuration is used:
 * ------------------------------------------------------------------------------------------
 * Element # |  Filter element configuration explanation
 * ------------------------------------------------------------------------------------------
 *     0     |  Reject messages with standard IDs in range [0x17-0x19]
 *     1     |  Accept messages with standard IDs in range [0x14-0x1A] and store them in RX FIFO 0
 *     2     |  Accept messages with standard IDs 0x184 or 0x187 and store them in RX FIFO 1
 *     3     |  Accept messages with standard ID 0x189 and store them in RX FIFO 0
 *     4     |  Accept messages according to the standard ID 0x200 and mask 0x39F and store them in RX FIFO 0
 *     5     |  Reject messages according to the standard ID 0x201 and mask 0x39F
 *     6     |  Accept messages with standard ID 0x325 and store them in dedicated RX buffer at index 0x2
 *     7     |  Accept messages with standard ID 0x326 and store them in dedicated RX buffer at index 0x5
 * ====================================================================================================================
 */
IfxCan_Filter g_filterStandardIdConfiguration[NUMBER_OF_STND_ID_FILTERS] =
{
    { 0, IfxCan_FilterElementConfiguration_rejectId,        IfxCan_FilterType_range,    0x017, 0x019,                   DO_NOT_CARE_BUFFER_INDEX },
    { 1, IfxCan_FilterElementConfiguration_storeInRxFifo0,  IfxCan_FilterType_range,    0x014, 0x01A,                   DO_NOT_CARE_BUFFER_INDEX },
    { 2, IfxCan_FilterElementConfiguration_storeInRxFifo1,  IfxCan_FilterType_dualId,   0x184, 0x187,                   DO_NOT_CARE_BUFFER_INDEX },
    { 3, IfxCan_FilterElementConfiguration_storeInRxFifo0,  IfxCan_FilterType_dualId,   0x189, 0x189,                   DO_NOT_CARE_BUFFER_INDEX },
    { 4, IfxCan_FilterElementConfiguration_storeInRxFifo0,  IfxCan_FilterType_classic,  0x200, 0x39F,                   DO_NOT_CARE_BUFFER_INDEX },
    { 5, IfxCan_FilterElementConfiguration_rejectId,        IfxCan_FilterType_classic,  0x201, 0x39F,                   DO_NOT_CARE_BUFFER_INDEX },
    { 6, IfxCan_FilterElementConfiguration_storeInRxBuffer, IfxCan_FilterType_none,     0x325, DO_NOT_CARE_ID2_VALUE,   IfxCan_RxBufferId_2 },
    { 7, IfxCan_FilterElementConfiguration_storeInRxBuffer, IfxCan_FilterType_none,     0x326, DO_NOT_CARE_ID2_VALUE,   IfxCan_RxBufferId_5 }
};

/* ====================================================================================================================
 * For this example the following extended ID filter configuration is used:
 * ------------------------------------------------------------------------------------------
 * Element # |  Filter element configuration explanation
 * ------------------------------------------------------------------------------------------
 *     0     |  Accept messages with extended ID 0x12222222 and store them in dedicated RX buffer at index 0x0
 *     1     |  Accept messages with extended IDs in range [0x19999999-0x1BBBBBBB] and store them in RX FIFO 1
 *     2     |  Accept messages with extended ID 0x1FFABCDE and store them in RX FIFO 0
 *     3     |  Accept messages with extended ID 0x16666666 and store them in RX FIFO 1
 * ====================================================================================================================
 */
IfxCan_Filter g_filterExtendedIdConfiguration[NUMBER_OF_EXTD_ID_FILTERS] =
{
    { 0, IfxCan_FilterElementConfiguration_storeInRxBuffer, IfxCan_FilterType_none,     0x12222222, DO_NOT_CARE_ID2_VALUE,  IfxCan_RxBufferId_0 },
    { 1, IfxCan_FilterElementConfiguration_storeInRxFifo1,  IfxCan_FilterType_range,    0x19999999, 0x1BBBBBBB,             DO_NOT_CARE_BUFFER_INDEX },
    { 2, IfxCan_FilterElementConfiguration_storeInRxFifo0,  IfxCan_FilterType_dualId,   0x1FFABCDE, 0x1FFABCDE,             DO_NOT_CARE_BUFFER_INDEX },
    { 3, IfxCan_FilterElementConfiguration_storeInRxFifo1,  IfxCan_FilterType_none,     0x16666666, 0x16666666,             DO_NOT_CARE_BUFFER_INDEX }
};

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define Interrupt Service Routine.
 * This macro:
 * - defines linker section as .intvec_tc<vector number>_<interrupt priority>.
 * - defines compiler specific attribute for the interrupt functions.
 * - defines the Interrupt service routine as ISR function.
 *
 * IFX_INTERRUPT(isr, vectabNum, priority)
 *  - isr: Name of the ISR function.
 *  - vectabNum: Vector table number.
 *  - priority: Interrupt priority. Refer Usage of Interrupt Macro for more details.
 */
IFX_INTERRUPT(canIsrRxBufferHandler, 0, ISR_PRIORITY_CAN_RX_BUFFER);
IFX_INTERRUPT(canIsrRxFifo0Handler, 0, ISR_PRIORITY_CAN_RX_FIFO_0);
IFX_INTERRUPT(canIsrRxFifo1Handler, 0, ISR_PRIORITY_CAN_RX_FIFO_1);

/* Interrupt Service Routine (ISR) called once the dedicated RX buffer interrupt has been generated */
void canIsrRxBufferHandler(void)
{
    IfxCan_RxBufferId rxBufferId = IfxCan_RxBufferId_0;

    /* Clear the "Message stored to Dedicated RX Buffer" interrupt flag */
    IfxCan_Node_clearInterruptFlag(g_mcmcan.canDstNode.node, IfxCan_Interrupt_messageStoredToDedicatedRxBuffer);

    /* Received message content should be updated with the data stored in the dedicated RX buffer */
    g_mcmcan.rxMsg[g_currentFilterUseCase].readFromRxFifo0 = FALSE;
    g_mcmcan.rxMsg[g_currentFilterUseCase].readFromRxFifo1 = FALSE;

    while(!IfxCan_Node_isRxBufferNewDataUpdated(g_mcmcan.canDstNode.node, rxBufferId))
    {
        rxBufferId++;
    }

    g_mcmcan.rxMsg[g_currentFilterUseCase].bufferNumber = (uint8)rxBufferId;

    /* Read the received CAN message */
    IfxCan_Can_readMessage(&g_mcmcan.canDstNode,
                           &g_mcmcan.rxMsg[g_currentFilterUseCase],
                           (uint32*)&g_mcmcan.rxData[g_currentFilterUseCase][0]);
}

/* Interrupt Service Routine (ISR) called once the RX FIFO 0 interrupt has been generated */
void canIsrRxFifo0Handler(void)
{
    /* Clear the "RX FIFO 0 new message" interrupt flag */
    IfxCan_Node_clearInterruptFlag(g_mcmcan.canDstNode.node, IfxCan_Interrupt_rxFifo0NewMessage);

    /* Received message content should be updated with the data stored in the RX FIFO 0 */
    g_mcmcan.rxMsg[g_currentFilterUseCase].readFromRxFifo0 = TRUE;
    g_mcmcan.rxMsg[g_currentFilterUseCase].readFromRxFifo1 = FALSE;

    /* Read the received CAN message */
    IfxCan_Can_readMessage(&g_mcmcan.canDstNode,
                           &g_mcmcan.rxMsg[g_currentFilterUseCase],
                           (uint32*)&g_mcmcan.rxData[g_currentFilterUseCase][0]);
}

/* Interrupt Service Routine (ISR) called once the RX FIFO 1 interrupt has been generated */
void canIsrRxFifo1Handler(void)
{
    /* Clear the "RX FIFO 1 new message" interrupt flag */
    IfxCan_Node_clearInterruptFlag(g_mcmcan.canDstNode.node, IfxCan_Interrupt_rxFifo1NewMessage);

    /* Received message content should be updated with the data stored in the RX FIFO 1 */
    g_mcmcan.rxMsg[g_currentFilterUseCase].readFromRxFifo0 = FALSE;
    g_mcmcan.rxMsg[g_currentFilterUseCase].readFromRxFifo1 = TRUE;

    /* Read the received CAN message */
    IfxCan_Can_readMessage(&g_mcmcan.canDstNode,
                           &g_mcmcan.rxMsg[g_currentFilterUseCase],
                           (uint32*)&g_mcmcan.rxData[g_currentFilterUseCase][0]);
}

/* Function to initialize MCMCAN module and nodes related for this application use case */
void initMCMCAN(void)
{
    uint8 currentFilterElement;

    /* ==========================================================================================
     * CAN module configuration and initialization:
     * ==========================================================================================
     *  - Load default CAN module configuration into configuration structure
     *  - Initialize CAN module with the default configuration
     * ==========================================================================================
     */
    IfxCan_Can_initModuleConfig(&g_mcmcan.canConfig, &MODULE_CAN0);

    IfxCan_Can_initModule(&g_mcmcan.canModule, &g_mcmcan.canConfig);

    /* ==========================================================================================
     * Source CAN node configuration and initialization:
     * ==========================================================================================
     *  - Load default CAN node configuration into configuration structure
     *
     *  - Set source CAN node in the "Loop-Back" mode (no external pins are used)
     *  - Assign source CAN node to CAN node 0
     *
     *  - Define the frame type as transmitting frame
     *  - Define the node to be in the "CAN FD long + fast" frame mode
     *
     *  - TX dedicated buffer should be used for transmission
     *  - The size of the TX dedicated buffer corresponds to the maximum CAN FD payload length
     *
     *  - Initialize the source CAN node with the modified configuration
     * ==========================================================================================
     */
    IfxCan_Can_initNodeConfig(&g_mcmcan.canNodeConfig, &g_mcmcan.canModule);

    g_mcmcan.canNodeConfig.busLoopbackEnabled = TRUE;
    g_mcmcan.canNodeConfig.nodeId = IfxCan_NodeId_0;

    g_mcmcan.canNodeConfig.frame.type = IfxCan_FrameType_transmit;
    g_mcmcan.canNodeConfig.frame.mode = IfxCan_FrameMode_fdLongAndFast;

    g_mcmcan.canNodeConfig.txConfig.txMode = IfxCan_TxMode_dedicatedBuffers;
    g_mcmcan.canNodeConfig.txConfig.txBufferDataFieldSize = IfxCan_DataFieldSize_64;

    IfxCan_Can_initNode(&g_mcmcan.canSrcNode, &g_mcmcan.canNodeConfig);

    /* ==========================================================================================
     * Destination CAN node configuration and initialization:
     * ==========================================================================================
     * Due to the configuration and initialization complexity for the destination CAN node,
     * the necessary procedure can be separate into several steps:
     *
     *  - Loading the default CAN node configuration into a configuration structure
     *  - General node configuration
     *  - Frame configuration
     *  - Reception handling configuration
     *  - General filter configuration
     *  - Interrupt configuration
     *  - Initialization of the destination CAN node with the modified configuration
     *  - Initialization of standard and extended ID filter elements
     *
     * ------------------------------------------------------------------------------------------
     * Loading the default CAN node configuration into configuration structure
     * ------------------------------------------------------------------------------------------
     */
    IfxCan_Can_initNodeConfig(&g_mcmcan.canNodeConfig, &g_mcmcan.canModule);

    /* ------------------------------------------------------------------------------------------
     * General node configuration
     * ------------------------------------------------------------------------------------------
     *  - Set destination CAN node in the "Loop-Back" mode (no external pins are used)
     *  - Assign destination CAN node to CAN node 1
     * ------------------------------------------------------------------------------------------
     */
    g_mcmcan.canNodeConfig.busLoopbackEnabled = TRUE;
    g_mcmcan.canNodeConfig.nodeId = IfxCan_NodeId_1;

    /* ------------------------------------------------------------------------------------------
     * Frame configuration
     * ------------------------------------------------------------------------------------------
     *  - Define the frame type as receiving frame
     *  - Define the node to be in the "CAN FD long + fast" frame mode
     * ------------------------------------------------------------------------------------------
     */
    g_mcmcan.canNodeConfig.frame.type = IfxCan_FrameType_receive;
    g_mcmcan.canNodeConfig.frame.mode = IfxCan_FrameMode_fdLongAndFast;

    /* ------------------------------------------------------------------------------------------
     * Reception handling configuration
     * ------------------------------------------------------------------------------------------
     *  - The received CAN messages can be stored in the dedicated RX buffer or RX FIFO 0 or RX FIFO 1
     *  - Dedicated RX buffer element size should correspond to the maximum CAN FD payload length
     *  - RX FIFO 0 buffer element size should correspond to the maximum CAN FD payload length
     *  - RX FIFO 1 buffer element size should correspond to the maximum CAN FD payload length
     *  - Define the size of the RX FIFO 0 to 15 elements
     *  - Define the size of the RX FIFO 1 to 15 elements
     * ------------------------------------------------------------------------------------------
     */
    g_mcmcan.canNodeConfig.rxConfig.rxMode = IfxCan_RxMode_sharedAll;
    g_mcmcan.canNodeConfig.rxConfig.rxBufferDataFieldSize = IfxCan_DataFieldSize_64;
    g_mcmcan.canNodeConfig.rxConfig.rxFifo0DataFieldSize = IfxCan_DataFieldSize_64;
    g_mcmcan.canNodeConfig.rxConfig.rxFifo1DataFieldSize = IfxCan_DataFieldSize_64;
    g_mcmcan.canNodeConfig.rxConfig.rxFifo0Size = NUMBER_OF_FIFO_ELEMENTS;
    g_mcmcan.canNodeConfig.rxConfig.rxFifo1Size = NUMBER_OF_FIFO_ELEMENTS;

    /* ------------------------------------------------------------------------------------------
     * General filter configuration
     * ------------------------------------------------------------------------------------------
     *  - General filter configuration should be valid for both standard and extended ID messages
     *  - Define number of standard ID filter elements
     *  - Define number of extended ID filter elements
     *  - Accept non-matching messages with standard IDs and store them to RX FIFO 1
     *  - Reject non-matching messages with extended IDs
     *  - Reject remote frames with standard IDs
     *  - Reject remote frames with extended IDs
     * ------------------------------------------------------------------------------------------
     */
    g_mcmcan.canNodeConfig.filterConfig.messageIdLength = IfxCan_MessageIdLength_both;
    g_mcmcan.canNodeConfig.filterConfig.standardListSize = NUMBER_OF_STND_ID_FILTERS;
    g_mcmcan.canNodeConfig.filterConfig.extendedListSize = NUMBER_OF_EXTD_ID_FILTERS;
    g_mcmcan.canNodeConfig.filterConfig.standardFilterForNonMatchingFrames = IfxCan_NonMatchingFrame_acceptToRxFifo1;
    g_mcmcan.canNodeConfig.filterConfig.extendedFilterForNonMatchingFrames = IfxCan_NonMatchingFrame_reject;
    g_mcmcan.canNodeConfig.filterConfig.rejectRemoteFramesWithStandardId = TRUE;
    g_mcmcan.canNodeConfig.filterConfig.rejectRemoteFramesWithExtendedId = TRUE;

    /* ------------------------------------------------------------------------------------------
     * Interrupt configuration
     * ------------------------------------------------------------------------------------------
     *  - Once the message is stored in the dedicated RX buffer/RX FIFO 0/RX FIFO 1, raise an interrupt
     *  - Define the reception interrupt priority (1/2/3)
     *  - Assign the interrupt line 1/2/3 to the reception interrupt
     *  - Reception interrupt service routine should be serviced by the CPU0
     * ------------------------------------------------------------------------------------------
     */
    g_mcmcan.canNodeConfig.interruptConfig.messageStoredToDedicatedRxBufferEnabled = TRUE;
    g_mcmcan.canNodeConfig.interruptConfig.reint.priority = ISR_PRIORITY_CAN_RX_BUFFER;
    g_mcmcan.canNodeConfig.interruptConfig.reint.interruptLine = IfxCan_InterruptLine_1;
    g_mcmcan.canNodeConfig.interruptConfig.reint.typeOfService = IfxSrc_Tos_cpu0;

    g_mcmcan.canNodeConfig.interruptConfig.rxFifo0NewMessageEnabled = TRUE;
    g_mcmcan.canNodeConfig.interruptConfig.rxf0n.priority = ISR_PRIORITY_CAN_RX_FIFO_0;
    g_mcmcan.canNodeConfig.interruptConfig.rxf0n.interruptLine = IfxCan_InterruptLine_2;
    g_mcmcan.canNodeConfig.interruptConfig.rxf0n.typeOfService = IfxSrc_Tos_cpu0;

    g_mcmcan.canNodeConfig.interruptConfig.rxFifo1NewMessageEnabled = TRUE;
    g_mcmcan.canNodeConfig.interruptConfig.rxf1n.priority = ISR_PRIORITY_CAN_RX_FIFO_1;
    g_mcmcan.canNodeConfig.interruptConfig.rxf1n.interruptLine = IfxCan_InterruptLine_3;
    g_mcmcan.canNodeConfig.interruptConfig.rxf1n.typeOfService = IfxSrc_Tos_cpu0;

    /* ------------------------------------------------------------------------------------------
     * Initialization of the destination CAN node with the modified configuration
     * ------------------------------------------------------------------------------------------
     */
    IfxCan_Can_initNode(&g_mcmcan.canDstNode, &g_mcmcan.canNodeConfig);

    /* ------------------------------------------------------------------------------------------
     * Initialization of standard and extended ID filter elements
     * ==========================================================================================
     */
    for(currentFilterElement = 0; currentFilterElement < NUMBER_OF_STND_ID_FILTERS; currentFilterElement++)
    {
        IfxCan_Can_setStandardFilter(&g_mcmcan.canDstNode, &g_filterStandardIdConfiguration[currentFilterElement]);
    }
    for(currentFilterElement = 0; currentFilterElement < NUMBER_OF_EXTD_ID_FILTERS; currentFilterElement++)
    {
        IfxCan_Can_setExtendedFilter(&g_mcmcan.canDstNode, &g_filterExtendedIdConfiguration[currentFilterElement]);
    }
}

/* Function to initialize both TX and RX messages with the default values.
 * After initialization of the messages, the TX message is transmitted.
 */
void transmitCanMessage(void)
{
    uint8 currentDataPayloadWord;

    for(g_currentFilterUseCase = 0; g_currentFilterUseCase < NUMBER_OF_CAN_MESSAGES; g_currentFilterUseCase++)
    {
        /* Initialization of the RX message with the default configuration and invalidation of specific parameters */
        IfxCan_Can_initMessage(&g_mcmcan.rxMsg[g_currentFilterUseCase]);

        g_mcmcan.rxMsg[g_currentFilterUseCase].messageId = INVALID_ID_VALUE;
        g_mcmcan.rxMsg[g_currentFilterUseCase].dataLengthCode = INVALID_DLC_VALUE;
        g_mcmcan.rxMsg[g_currentFilterUseCase].frameMode = DEFAULT_FRAME_MODE;

        /* Invalidation of the RX message data content */
        memset((void *)(&g_mcmcan.rxData[g_currentFilterUseCase][0]), INVALID_RX_DATA_VALUE, MAXIMUM_CAN_FD_DATA_PAYLOAD);

        /* Invalidation of the TX message data content */
        memset((void *)(&g_mcmcan.txData[0]), INVALID_TX_DATA_VALUE, MAXIMUM_CAN_FD_DATA_PAYLOAD);

        /* Initialization of the TX message with the default configuration */
        IfxCan_Can_initMessage(&g_mcmcan.txMsg);

        /* ==========================================================================================
         * Configuration of the TX message based on the "g_useCaseConf" table:
         * ==========================================================================================
         *  - Set the message ID value (related to the TxMsgk_T0(k=0-31).ID bit field)
         *  - Set the length of the message ID value (related to the TxMsgk_T0(k=0-31).XTD bit field)
         *  - Define the frame mode that should be used (related to the TxMsgk_T1(k=0-31).FDF/.BRS bit fields)
         *  - Define the data length code (related to the TxMsgk_T1(k=0-31).DLC bit field)
         * ==========================================================================================
         */
        g_mcmcan.txMsg.messageId = g_useCaseConf[g_currentFilterUseCase].messageId;
        g_mcmcan.txMsg.messageIdLength = g_useCaseConf[g_currentFilterUseCase].messageIdLength;
        g_mcmcan.txMsg.frameMode = g_useCaseConf[g_currentFilterUseCase].frameMode;
        g_mcmcan.txMsg.dataLengthCode = g_useCaseConf[g_currentFilterUseCase].messageLen;

        /* Initialization of the TX message data content */
        for(currentDataPayloadWord = 0;
                currentDataPayloadWord < g_dlcLookUpTableWord[g_useCaseConf[g_currentFilterUseCase].messageLen];
                currentDataPayloadWord++)
        {
            /* Each CAN message data payload word is initialized in the following format (other empty fields equal to "0"):
             * ======================================================================================================================
             *  bit |  31  |  30  |  29  |  28  |  27  |  26  |  25  |  24  |  23  |  22  |  21  |  20  |  19  |  18  |  17  |  16  |
             * ======================================================================================================================
             *      |      |      |      |      g_currentFilterUseCase      |      |      |      |      |      |      |      |      |
             *      |      |      |      |            (range: 0-24)         |      |      |      |      |      |      |      |      |
             * ======================================================================================================================
             *  bit |  15  |  14  |  13  |  12  |  11  |  10  |   9  |   8  |   7  |   6  |   5  |   4  |   3  |   2  |   1  |   0  |
             * ======================================================================================================================
             *      |      |      |      |      |      |      |      |      |      |      |      |      |  currentDataPayloadWord   |
             *      |      |      |      |      |      |      |      |      |      |      |      |      |       (range: 0-15)       |
             * ======================================================================================================================
             */
            g_mcmcan.txData[currentDataPayloadWord] = DATA_PAYLOAD(g_currentFilterUseCase, currentDataPayloadWord);
        }

        /* Send the CAN message with the previously defined TX message configuration and content */
        while(IfxCan_Status_notSentBusy == IfxCan_Can_sendMessage(&g_mcmcan.canSrcNode, &g_mcmcan.txMsg, (uint32*)&g_mcmcan.txData[0]))
        {
        }

        /* Initialize a time variable for waiting 1 ms */
        Ifx_TickTime ticksFor1ms = IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME);

        /* Adding additional time delay so we are sure that acceptance filtering took place by the node 1 */
        wait(ticksFor1ms);
    }
}

/* Function to verify CAN message.
 * After each message has been received, several checks are performed:
 *     - Message ID check
 *     - Message length check
 *     - Frame mode check
 *     - Received message storage destination check
 *     - Data content check (expected valid data and unchanged invalid data)
 */
void verifyCanMessage(void)
{
    uint8 currentDataPayloadWord, currentRxCanMessage;

    for(currentRxCanMessage = 0; currentRxCanMessage < NUMBER_OF_CAN_MESSAGES; currentRxCanMessage++)
    {
        /* Check if the received message ID does NOT match the expected message ID.
         * Expected message ID differs if the message is expected to be accepted or rejected.
         * If this is the case, an error should be reported.
         */
        if(g_useCaseConf[currentRxCanMessage].acceptanceResult == CanFilterAcceptance_Accept)
        {
            if(g_mcmcan.rxMsg[currentRxCanMessage].messageId != g_useCaseConf[currentRxCanMessage].messageId)
            {
                g_status = CanCommunicationStatus_Error_notExpectedMessageId;
            }
        }
        else
        {
            if(g_mcmcan.rxMsg[currentRxCanMessage].messageId != INVALID_ID_VALUE)
            {
                g_status = CanCommunicationStatus_Error_notExpectedMessageId;
            }
        }

        /* Check if the received message length does NOT match the expected message length.
         * Expected message length differs if the message is expected to be accepted or rejected.
         * If this is the case, an error should be reported.
         */
        if(g_useCaseConf[currentRxCanMessage].acceptanceResult == CanFilterAcceptance_Accept)
        {
            if(g_mcmcan.rxMsg[currentRxCanMessage].dataLengthCode != g_useCaseConf[currentRxCanMessage].messageLen)
            {
                g_status = CanCommunicationStatus_Error_notExpectedLengthCode;
            }
        }
        else
        {
            if(g_mcmcan.rxMsg[currentRxCanMessage].dataLengthCode != INVALID_DLC_VALUE)
            {
                g_status = CanCommunicationStatus_Error_notExpectedLengthCode;
            }
        }

        /* Check if the received frame mode bit does NOT match the expected frame mode value.
         * Expected frame mode value differs if the message is expected to be accepted or rejected.
         * If this is the case, an error should be reported.
         */
        if(g_useCaseConf[currentRxCanMessage].acceptanceResult == CanFilterAcceptance_Accept)
        {
            if(g_mcmcan.rxMsg[currentRxCanMessage].frameMode != g_useCaseConf[currentRxCanMessage].frameMode)
            {
                g_status = CanCommunicationStatus_Error_notExpectedFrameMode;
            }
        }
        else
        {
            if(g_mcmcan.rxMsg[currentRxCanMessage].frameMode != DEFAULT_FRAME_MODE)
            {
                g_status = CanCommunicationStatus_Error_notExpectedFrameMode;
            }
        }

        /* Check if the received message storage destination does NOT match the expected storage destination.
         * Expected storage destination differs if the message is expected to be accepted or rejected.
         * If this is the case, an error should be reported.
         */
        switch(g_useCaseConf[currentRxCanMessage].destination)
        {
            case CanStoreInDestinationType_notApplicable:
                if ((g_useCaseConf[currentRxCanMessage].acceptanceResult != CanFilterAcceptance_Reject) || \
                        (g_mcmcan.rxMsg[currentRxCanMessage].dataLengthCode != INVALID_DLC_VALUE))
                {
                    g_status = CanCommunicationStatus_Error_notExpectedStorageDestination;
                }
                break;
            case CanStoreInDestinationType_RxBuffer:
                if ((g_mcmcan.rxMsg[currentRxCanMessage].readFromRxFifo0 != FALSE) || \
                        (g_mcmcan.rxMsg[currentRxCanMessage].readFromRxFifo1 != FALSE))
                {
                    g_status = CanCommunicationStatus_Error_notExpectedStorageDestination;
                }
                break;
            case CanStoreInDestinationType_RxFifo0:
                if ((g_mcmcan.rxMsg[currentRxCanMessage].readFromRxFifo0 != TRUE) || \
                        (g_mcmcan.rxMsg[currentRxCanMessage].readFromRxFifo1 != FALSE))
                {
                    g_status = CanCommunicationStatus_Error_notExpectedStorageDestination;
                }
                break;
            case CanStoreInDestinationType_RxFifo1:
                if ((g_mcmcan.rxMsg[currentRxCanMessage].readFromRxFifo0 != FALSE) || \
                        (g_mcmcan.rxMsg[currentRxCanMessage].readFromRxFifo1 != TRUE))
                {
                    g_status = CanCommunicationStatus_Error_notExpectedStorageDestination;
                }
                break;
        }

        /* Finally, check if the received data does NOT match the expected one.
         * If this is the case, an error should be reported.
         *
         * Both "rxData" and "txData" arrays have the size of MAXIMUM_CAN_FD_DATA_PAYLOAD (64 bytes). Additionally, both
         * of the arrays are fully initialized so the possible incorrect number of transmitted words can be detected.
         * For this reason, the check is performed in two steps:
         *     - First "for" loop compares the valid expected data to the received data. The "currentDataPayloadWord"
         *       iterator variable is incremented up to the number of words defined by the "g_mcmcan.rxMsg.dataLengthCode"
         *       variable. This value equals to the number of valid expected data words.
         *     - Second "for" loop checks the invalid data to ensure that the content has not been changed.
         *       The "currentDataPayloadWord" iterator variable is incremented from the current value of the variable
         *       (for this reason the initialization part of the second "for" loop is omitted) up to the
         *       MAXIMUM_DATA_PAYLOAD_WORDS (64 bytes / sizeof(int) = 16 words) value.
         */
        for(currentDataPayloadWord = 0;
            currentDataPayloadWord < g_dlcLookUpTableWord[g_useCaseConf[currentRxCanMessage].messageLen];
            currentDataPayloadWord++)
        {
            if(g_useCaseConf[currentRxCanMessage].acceptanceResult == CanFilterAcceptance_Accept)
            {
                if(g_mcmcan.rxData[currentRxCanMessage][currentDataPayloadWord] != \
                                                            DATA_PAYLOAD(currentRxCanMessage, currentDataPayloadWord))
                {
                    g_status = CanCommunicationStatus_Error_notExpectedData;
                }
            }
            else
            {
                if(g_mcmcan.rxData[currentRxCanMessage][currentDataPayloadWord] != INVALID_RX_DATA_VALUE)
                {
                    g_status = CanCommunicationStatus_Error_notExpectedData;
                }
            }
        }

        for(/*...*/;
            currentDataPayloadWord < MAXIMUM_DATA_PAYLOAD_WORDS;
            currentDataPayloadWord++)
        {
            if(g_mcmcan.rxData[currentRxCanMessage][currentDataPayloadWord] != INVALID_RX_DATA_VALUE)
            {
                g_status = CanCommunicationStatus_Error_notExpectedData;
            }
        }

        if(g_status != CanCommunicationStatus_Success)
        {
            break;
        }
    }
}


/* Function to initialize the port pin that is connected to the LED */
void initLed(void)
{
    /* ======================================================================
     * Configuration of the port pin connected to the LED:
     * ======================================================================
     *  - Define the GPIO port
     *  - Define the GPIO pin that is connected to the LED
     *  - Define the general GPIO pin usage (no alternate function used)
     *  - Define the pad driver strength
     * ======================================================================
     */
    g_led1.port      = &MODULE_P13;
    g_led1.pinIndex  = PIN0;
    g_led1.mode      = IfxPort_OutputIdx_general;
    g_led1.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1;

    /* Initialize the port pin connected to LED to level "HIGH"; this keeps the LED turned off as default state */
    IfxPort_setPinHigh(g_led1.port, g_led1.pinIndex);

    /* Set the pin input/output mode for the port pin connected to the LED */
    IfxPort_setPinModeOutput(g_led1.port, g_led1.pinIndex, IfxPort_OutputMode_pushPull, g_led1.mode);

    /* Set the pad driver mode for the port pin connected to the LED */
    IfxPort_setPinPadDriver(g_led1.port, g_led1.pinIndex, g_led1.padDriver);
}
