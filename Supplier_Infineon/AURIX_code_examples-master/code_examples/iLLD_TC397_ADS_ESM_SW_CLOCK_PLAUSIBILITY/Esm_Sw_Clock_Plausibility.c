/**********************************************************************************************************************
 * \file    Esm_Sw_Clock_Plausibility.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "IfxPort.h"
#include "IfxCpu_Irq.h"
#include "IfxStm.h"
#include "Esm_Sw_Clock_Plausibility.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* CPU which run this ESM */
#define CPU_WHICH_RUN_CLK_PLAUS_ESM     0

/* LEDs on Application Kit */
#define LED_D107_CHECH_FAIL             &MODULE_P13, 0          /* LED D107: Port, Pin definition                    */
#define LED_D108_CHECK_PASS             &MODULE_P13, 1          /* LED D108: Port, Pin definition                    */
#define LED_D109_TRANSFER_DONE          &MODULE_P13, 2          /* LED D108: Port, Pin definition                    */

#define MASTER_CHANNEL_BAUDRATE         10000000                /* Master channel baud rate 10MHz                    */

#define SEC_TO_MIRCO_SEC                1000000                 /* 1 second = 1000000 microsecond                    */
#define EXPECTED_TIME                   100.01                  /* time in microsecond                               */
#define TRANSFER_TIME_MAX_LIMIT         (EXPECTED_TIME + (EXPECTED_TIME * 0.05))      /* 5% of expected time         */
#define TRANSFER_TIME_MIN_LIMIT         (EXPECTED_TIME - (EXPECTED_TIME * 0.05))      /* 5% of expected time         */

/* ISR Priority */
#define ISR_PRIORITY_QSPI5_PT_CLK_PlAUS             1  /* Define QSPI Phase Transition interrupt priority            */
#define ISR_PRIORITY_QSPI5_ER_CLK_PlAUS             2  /* Define the QSPI5 error interrupt priority                  */
#define ISR_PRIORITY_QSPI5_RX_DMA_CH3_CLK_PlAUS     3  /* DMA ch3 interrupt priority                                 */
#define ISR_PRIORITY_QSPI5_TX_DMA_CH2_CLK_PlAUS     4  /* DMA ch2 interrupt priority for clock plausibility          */
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
qspiDma g_qspiDma;                                     /* Global handle for QSPI communication                       */
float32 g_qspiTransferTime;                            /* one complete master transfer time                          */
volatile static float32 g_injectErrorValue = 0;        /* User Injected Error Value                                  */
/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void enableInterruptPT(void);
void initQSPI5Master(void);
void initQSPI5MasterChannel(void);
void initQSPI5MasterBuffers(void);
void initLEDs(void);
void initQSPI5ForClockPlausibility(void);

/* DMA Channel 2 Interrupt definition */
IFX_INTERRUPT(DMAChn2ISR_Tx, CPU_WHICH_RUN_CLK_PLAUS_ESM, ISR_PRIORITY_QSPI5_TX_DMA_CH2_CLK_PlAUS);
/* DMA Channel 3 Interrupt definition */
IFX_INTERRUPT(DMAChn3ISR_Rx, CPU_WHICH_RUN_CLK_PLAUS_ESM, ISR_PRIORITY_QSPI5_RX_DMA_CH3_CLK_PlAUS);
/* SPI Master Error Interrupt definition */
IFX_INTERRUPT(QSPI5ErrorISR, CPU_WHICH_RUN_CLK_PLAUS_ESM, ISR_PRIORITY_QSPI5_ER_CLK_PlAUS);
/* QSPI5 Phase Transition Interrupt definition */
IFX_INTERRUPT(QSPI5ISR_Pt, CPU_WHICH_RUN_CLK_PLAUS_ESM, ISR_PRIORITY_QSPI5_PT_CLK_PlAUS);
/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Handle QSPI5 Error interrupt */
void QSPI5ErrorISR(void)
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrError(&g_qspiDma.spiMaster);
}

/* Handle DMA Channel 2 interrupt */
void DMAChn2ISR_Tx(void)
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrDmaTransmit(&g_qspiDma.spiMaster);
}

/* Handle DMA Channel 3 interrupt */
void DMAChn3ISR_Rx(void)
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrDmaReceive(&g_qspiDma.spiMaster);
}

/* Handle QSPI5 Phase Transition interrupt */
void QSPI5ISR_Pt(void)
{
    static uint64 stmStartOfFrame, stmEndOfFrame;
    uint64 eventTime;
    IfxQspi_PhaseTransitionEvent event;

    /* capture time when event occurs */
    eventTime = IfxStm_get(&MODULE_STM0);

    IfxCpu_enableInterrupts();
    event = IfxQspi_SpiMaster_isrPhaseTransition(&g_qspiDma.spiMaster);
    /* Process phase transition event */
    switch (event)
    {
        /* Start Of Frame (SOF) event */
        case IfxQspi_PhaseTransitionEvent_startOfFrame:
            stmStartOfFrame = eventTime;
            break;

        /* End Of Frame (EOF) event */
        case IfxQspi_PhaseTransitionEvent_endOfFrame:
            stmEndOfFrame = eventTime;

            /* Ticks/Fstm = time in second */
            g_qspiTransferTime = (float32)(stmEndOfFrame - stmStartOfFrame)/(IfxStm_getFrequency(&MODULE_STM0));

            /* seconds to microseconds */
            g_qspiTransferTime = g_qspiTransferTime * SEC_TO_MIRCO_SEC;

            /* check the clock plausibility  */
            checkClockPlausibility();
            break;

            /* add other events if needed */
        case IfxQspi_PhaseTransitionEvent_endOfWait:
        case IfxQspi_PhaseTransitionEvent_serialClockPolarityChange:
        case IfxQspi_PhaseTransitionEvent_transmitBufferEmptied:
        case IfxQspi_PhaseTransitionEvent_receiveBufferFilled:
        case IfxQspi_PhaseTransitionEvent_dataNotAvailable:
        case IfxQspi_PhaseTransitionEvent_endOfExpect:
            break;

        default:
            break;
    }
 }

/* enable the Phase Transition interrupt for QSPI5 */
void enableInterruptPT()
{
    volatile Ifx_SRC_SRCR *src = &MODULE_SRC.QSPI.QSPI[5].PT;
    if(CPU_WHICH_RUN_CLK_PLAUS_ESM)
    {
        IfxSrc_init(src, (IfxSrc_Tos)(CPU_WHICH_RUN_CLK_PLAUS_ESM +1), ISR_PRIORITY_QSPI5_PT_CLK_PlAUS);
    }
    else
    {
        IfxSrc_init(src, (IfxSrc_Tos)CPU_WHICH_RUN_CLK_PLAUS_ESM, ISR_PRIORITY_QSPI5_PT_CLK_PlAUS);
    }

    IfxSrc_enable(src);

    /* Configured for PT1 Start Of Frame event */
    IfxQspi_configPT1Event(&MODULE_QSPI5, IfxQspi_PhaseTransitionEvent_startOfFrame);
    IfxQspi_enablePT1Event(&MODULE_QSPI5, TRUE);

    /* Configured for PT1 End Of Frame event */
    IfxQspi_configPT2Event(&MODULE_QSPI5, IfxQspi_PhaseTransitionEvent_endOfFrame);
    IfxQspi_enablePT2Event(&MODULE_QSPI5, TRUE);
}

/* This function initializes QSPI5 in master mode */
void initQSPI5Master(void)
{
    /* Define the Master Configuration */
    IfxQspi_SpiMaster_Config spiMasterConfig;

    /* Initialize it with default values */
    IfxQspi_SpiMaster_initModuleConfig(&spiMasterConfig, &MODULE_QSPI5);

    /* Set baud rate to 10 MHz */
    spiMasterConfig.base.maximumBaudrate = MASTER_CHANNEL_BAUDRATE;
    /* Select the port pins for communication */
    const IfxQspi_SpiMaster_Pins qspi5Masterpins = {
        &IfxQspi5_SCLK_P14_10_OUT, IfxPort_OutputMode_pushPull,     /* SCLK Pin                          (CLK)  */
        &IfxQspi5_MTSR_P14_6_OUT, IfxPort_OutputMode_pushPull,      /* Master Transmit Slave Receive Pin (MOSI) */
        &IfxQspi5_MRSTB_P14_5_IN, IfxPort_InputMode_pullDown,       /* Master Receive Slave Transmit Pin (MISO) */
        IfxPort_PadDriver_cmosAutomotiveSpeed3                      /* Pad driver mode                          */
    };
    /* Assign Master Pins */
    spiMasterConfig.pins = &qspi5Masterpins;

    /* use DMA for transfer */
    spiMasterConfig.dma.useDma = TRUE;
    spiMasterConfig.dma.txDmaChannelId = IfxDma_ChannelId_2;
    spiMasterConfig.dma.rxDmaChannelId = IfxDma_ChannelId_3;

    /* Set the ISR priorities and the service provider */
    spiMasterConfig.base.txPriority = ISR_PRIORITY_QSPI5_TX_DMA_CH2_CLK_PlAUS;
    spiMasterConfig.base.rxPriority = ISR_PRIORITY_QSPI5_RX_DMA_CH3_CLK_PlAUS;
    spiMasterConfig.base.erPriority = ISR_PRIORITY_QSPI5_ER_CLK_PlAUS;

    if(CPU_WHICH_RUN_CLK_PLAUS_ESM)
    {
        spiMasterConfig.base.isrProvider = (IfxSrc_Tos)(CPU_WHICH_RUN_CLK_PLAUS_ESM + 1);
    }
    else
    {
        spiMasterConfig.base.isrProvider = (IfxSrc_Tos)CPU_WHICH_RUN_CLK_PLAUS_ESM;
    }

    /* Initialize the QSPI Master module using the user configuration */
    IfxQspi_SpiMaster_initModule(&g_qspiDma.spiMaster, &spiMasterConfig);

    /* enable Phase Transition interrupt for QPSI5 only */
    enableInterruptPT();
}

/*  This function initializes QSPI5 channel. */
void initQSPI5MasterChannel(void)
{
    /* Define the Master Channel Configuration  */
    IfxQspi_SpiMaster_ChannelConfig spiMasterChannelConfig;

    /* Initialize it with default values */
    IfxQspi_SpiMaster_initChannelConfig(&spiMasterChannelConfig, &g_qspiDma.spiMaster);

    /* Set SCLK frequency to 10 MHz */
    spiMasterChannelConfig.base.baudrate = MASTER_CHANNEL_BAUDRATE;

    /* Set spi master in XXL mode */
    spiMasterChannelConfig.mode = IfxQspi_SpiMaster_Mode_xxl;

    const IfxQspi_SpiMaster_Output qspi5SlaveSelect = {
        &IfxQspi5_SLSO3_P15_6_OUT, IfxPort_OutputMode_pushPull,    /* Slave Select Pin (CS) */
        IfxPort_PadDriver_cmosAutomotiveSpeed1                     /* Pad driver mode       */
    };
    /* Assign Slave port pins */
    spiMasterChannelConfig.sls.output = qspi5SlaveSelect;

    /* Initialize the QSPI Master channel using the user configuration */
    IfxQspi_SpiMaster_initChannel(&g_qspiDma.spiMasterChannel, &spiMasterChannelConfig);

}

/* This function initializes Master SW buffers */
void initQSPI5MasterBuffers(void)
{
    for (uint32 i = 0; i < SPI_BUFFER_SIZE_XXL; i++)
    {
        /* Fill the SPI Master TX Buffer  */
        g_qspiDma.qspiBuffer.spi5MasterTxBuffer[i] = (uint8)(i + 1);
        /* Clear the SPI Master RX Buffer */
        g_qspiDma.qspiBuffer.spi5MasterRxBuffer[i] = 0;
    }
}

/* This function initializes the port pin which drives the LED */
void initLEDs(void)
{
    /* Initialization of the LED used in this example */
    IfxPort_setPinModeOutput(LED_D107_CHECH_FAIL, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LED_D108_CHECK_PASS, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LED_D109_TRANSFER_DONE, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    /* Switch OFF the LED (low-level active) */
    IfxPort_setPinHigh(LED_D107_CHECH_FAIL);
    IfxPort_setPinHigh(LED_D108_CHECK_PASS);
    IfxPort_setPinHigh(LED_D109_TRANSFER_DONE);
}

/* This function initializes the QSPI5 module */
void initQSPI5ForClockPlausibility(void)
{
    /* Initialize the Master */
    initQSPI5Master();
    initQSPI5MasterChannel();
    initQSPI5MasterBuffers();
}

/* This function initialize the LEDs and QSPI module */
void initPeripherals()
{
    /* Initialize the LED port pin */
    initLEDs();

    /* Initial QSPI module */
    initQSPI5ForClockPlausibility();
}

/* This function ensures the QSPI data transfer by Master i.e. don't need
 * slave for this particular example
 */
void transferQSPIData(void)
{
    SpiIf_Status status;
    while (IfxQspi_SpiMaster_getStatus(&g_qspiDma.spiMasterChannel) == SpiIf_Status_busy)
    {
        /* Wait until the previous transfer has finished, if any */
    }

    /* send a data stream through the SPI Master */
    status = IfxQspi_SpiMaster_exchange(&g_qspiDma.spiMasterChannel, &g_qspiDma.qspiBuffer.spi5MasterTxBuffer[0],
                               NULL_PTR, SPI_BUFFER_SIZE_XXL);

    /* toggle LED to indicate transfer is done */
    if (status == SpiIf_Status_ok)
    {
        IfxPort_togglePin(LED_D109_TRANSFER_DONE);
    }
    else
    {
        IfxPort_setPinHigh(LED_D109_TRANSFER_DONE);
    }
}

/*
 * Function to check clock Plausibility on every EOF event
 * Software based ESM
 * */
void checkClockPlausibility(void)
{
    /* check clock plausibility range */
    if ( ((g_qspiTransferTime + g_injectErrorValue) > TRANSFER_TIME_MAX_LIMIT) ||
         (g_qspiTransferTime < TRANSFER_TIME_MIN_LIMIT) )
    {
        /* check plausibility test failed */
        IfxPort_setPinLow(LED_D107_CHECH_FAIL);
    }
    else
    {
        /* check plausibility test passed */
        IfxPort_setPinHigh(LED_D107_CHECH_FAIL);
        IfxPort_togglePin(LED_D108_CHECK_PASS);
    }
}
